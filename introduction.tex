\section{Introduction}
\label{sec:intro}

\marginpar{Intro still needs work}
Using active automata learning standard violations have been found in multiple implementations of
major network protocols such as TLS \cite{dRP15}, TCP \cite{FJV16} and SSH \cite{FiterauEtAl17}.
Timing often plays a crucial role in these applications but cannot be handled using existing tools.
Hence timing issues have been artificially suppressed in case studies.

There has been work on algorithms for learning timed systems, e.g., \cite{GrinchteinJL10,MensM15,CCF16},
but these approaches have complexity of these algorithms appears to be prohibitively high.
Also the specific restrictions of event recording automata sometimes make it hard to model
certain system behaviors that occur in practice.
For instance, a pattern that often occurs in protocols is that with $t$ time units after a first event $a$
there should be an event $b$, or else a timeout occurs.
% (For instance, in TCP a SYN should be followed by a SYN-ACK within a specified time interval.)
In an event recording automaton a clock is associated to each event, which is reset whenever that event occurs.
This means that upon occurrence of a second $a$ the automaton no longer remembers when the first $a$ has occurred,
and can thus not ensure the occurence of a timeout at the required moment in time.

We therefore decided to pursue a different approach. Rather than restricting the expressivity of general timed automata
until reaching a tractable model class, we explore tractable extensions of untimed automata models that appear to
be sufficiently expressive to describe the real-time behavior of practical applications.
%
Our work is inspired by recent work of Caldwell, Cardell-Oliver and French \cite{CCF16} on time delay Mealy machines.
We describe a simple variant of their model, Mealy machines with timers (MMTs), that 
(a) is able to model the timing behavior of a wide variety of communication protocols, and
(b) can be learned efficiently.
MMT's can be viewed as a formalization of the finite state machine models with countdown timers that are used by
Kurose and Ross \cite{KR13} to explain transport layer protocols.
Both time delay Mealy machines \cite{CCF16} and the event recording automata \cite{GrinchteinJL10} can not easily model such protocols.
 
Figure~\ref{fig:abp} presents a simplified model of the sender from 
the alternating-bit protocol, adapted from \cite[Figure 3.15]{KR13}.
\begin{figure}[h]
\centering
\vspace{-2 em}
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,main node/.style={circle,draw,font=\sffamily\large\bfseries}]
  \node[initial, state] (1) {$q_0$};
  \node[state] (2) [right of=1] {$q_1$};
  \node[state] (3) [below of=2] {$q_2$};
  \node[state] (4) [below of=1] {$q_3$};

  \path[every node/.style={font=\sffamily\scriptsize}]
    (1) edge [text width=1.5cm] node {$\mathit{in}/\mathit{send0}$ \\ $x := 3$} (2)
    (2) edge [text width=1.5cm] node {$\mathit{ack0}/\Lambda$ \\ $\mathit{stop}(x)$} (3)
        edge [loop right, text width=1.5cm] node {$\toevent{x}/\mathit{send0}$\\ $x := 3$ } (2)
    (3) edge [text width=1.5cm] node {$\mathit{in}/\mathit{send1}$ \\ $x := 3$} (4)
    (4) edge [text width=1cm] node {$\mathit{ack1}/\Lambda$ \\ $\mathit{stop}(x)$} (1)
        edge [loop left, text width=1.5cm] node {$\toevent{x}/\mathit{send1}$\\ $x := 3$} (4);
\end{tikzpicture}
\caption{Mealy machine with a timer for alternating-bit protocol sender}
\label{fig:abp}
\end{figure}
In the diagram we write $x :=3$ to denote that a transition (re)starts a timer $x$ with value $3$,
and we write $\mathit{stop}(x)$ if s transition stops timer $x$.
For readability we have omitted trivial self-loops.
\iflong
$\Lambda$ denotes the absence of an observable output. 

In the model, input $\mathit{in}$ corresponds to a request from the upper layer to transmit data.
Initially, upon receipt of such a request, the sender builds a packet from the data and a sequence number $0$,
sends the packet over the network (output $\mathit{send0}$), and starts the timer with timeout value $3$.
If the sender receives an acknowledgement with the right sequence number $0$ (input $\mathit{ack0}$) 
then it stops the timer and jumps to state $q_2$.
Acknowledgement with the incorrect sequence number (input $\mathit{ack1}$) are ignored.
If no $\mathit{ack0}$ input arrives within $3$ timeunits, a timeout occurs and the same packet is sent again.
The behavior in states $q_2$ and state $q_3$ is analogous to that in states $q_0$ and $q_1$, respectively,
with the roles of $0$ and $1$ swapped.
\fi

The remainder of this article is structured as follows.
In Section 2, we present the formal definition of MMTs and their timed semantics.
Our timed semantics records at which (real) times inputs and outputs may occur, but we cannot observe whether some timer is started
in response to an input. Since we assume that a timeout immediately triggers an observable output, we may observe
(indirectly) the occurrence of a timeout, but we cannot observe which timer times out.
In Section 3, we present a surprising result, namely that under certain assumptions the timed semantics is equivalent to an untimed
semantics in which we can infer, for each timeout event, which previous event caused this timeout.
Intuitively, causality of timeouts can be inferred since a slight change in the timing of an input event leads to a corresponding slight change in
the timing of any timeouts that it induces.
Section 4, we use some basic concepts from the theory of timed automata (zones and DBMs) to show how we can compute the set of timers that may
timeout following some untimed run.
Section 5 presents our learning algorithm for MMTs. The equivalence of the timed and the untimed semantics allows us to prove
a Myhill-Nerode theorem for MMTs, which provides the basis for our learning algorithm. Our algorithm uses a learning algorithm for
(untimed) Mealy machines as a subroutine.
Section 6 contains some concluding remarks and lists topics for future research.

