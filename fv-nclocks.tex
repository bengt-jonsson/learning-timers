\newcommand{\natplus}{\nat^{>0}}
\newcommand{\realsplus}{\bbbr^{\geq 0}}
\newcommand{\delays}{\bbbr^{> 0}}
\newcommand{\stoptimer}{\mathit{kill}}
\newcommand{\tosymbol}{\mathit{to}}
\newcommand{\toevent}[1]{\mathit{to}[#1]}
\newcommand{\toevents}{\mbox{\sl TO}}
\newcommand{\extinputs}{\hat{I}}
\newcommand{\acttimers}{\mathit{active}}
\newcommand{\Head}[1]{\mathsf{Head}({#1})}
\newcommand{\Tail}[1]{\mathsf{Tail}({#1})}
\newcommand{\Last}[1]{\mathsf{Last}({#1})}
\newcommand{\expirable}{\mathit{expirable}}
\newcommand{\tvals}{\kappa}
\newcommand{\Vals}[1]{\mathit{Val}({#1})}
\newcommand{\delay}[2]{t_{[#1:#2]}}
\newcommand{\timerof}[2]{x_{#1}^{#2}}
\newcommand{\constrof}[1]{\phi_{#1}}
\newcommand{\Post}{\mathsf{Post}}
\newcommand{\beh}{\mathit{beh}}
\newcommand{\untime}{\mathit{untime}}
\newcommand{\run}{\mathit{run}}
\newcommand{\timedword}{\mathit{tw}}

\newcommand{\conc}{\cdot}
\newcommand{\tuple}[1]{\langle #1\rangle}
\newcommand{\set}[1]{\lbrace #1\rbrace}
\newcommand{\vect}[2]{{#1}_1 , \ldots , {#1}_{#2}}
\newcommand{\setcomp}[2]{\set{#1 ~:~ #2}}
\newcommand{\domof}[1]{\dom(#1)}
\newcommand{\ranof}[1]{\ran(#1)}
\newcommand{\vars}{\mathcal{X}}
\newcommand{\varsof}[1]{\vars(#1)}
\newcommand{\ctimers}{X}
\newcommand{\remap}{\pi}
\newcommand{\remapinst}{\rho}
\newcommand{\normalize}{\gamma}
\newcommand{\normalizeof}[2]{\normalize_{#2}^{#1}}
\newcommand{\timerbij}{\gamma}
\newcommand{\timerequiv}{\pi}
\newcommand{\extendedby}{\lhd}
\newcommand{\uttrace}{\textsf{tr}}
\newcommand{\uttraceof}[1]{\uttrace(#1)}
\newcommand{\uttracesof}[1]{\textsf{Tr}(#1)}
\newcommand{\strace}{\textsf{tr}_s}
\newcommand{\ssuffix}{v_s}
\newcommand{\suftraces}{\textsf{Tr}_s}
\newcommand{\pinpof}[1]{\textit{inp}_p(#1)}
\newcommand{\sinpof}[1]{\textit{inp}_s(#1)}
\newcommand{\symbinpof}[1]{\textit{symbinp}(#1)}
\newcommand{\word}{w}
\newcommand{\smap}{{\cal O}}
\newcommand{\smappre}{{\cal O_p}}
\newcommand{\smapsuf}{{\cal O_s}}
\newcommand{\obspre}{{\cal O_U}}

\section{General Treatment for Arbitrary Number of Timers}

It is now time to consider the general case of
Mealy machines with an arbitrary number of timers (MMT). 
These just generalize MM1Ts in that they have a set of timers that
can be manipulated in the same way as the timer of a MM1T.

\subsection{MMTs}
We assume an unbounded set $X$ of {\em timers};
we use $x$, $x_1$, $x_2$, etc.\ to range over timers.
Let $\toevents$ be the set of {\em timeout events} of form
$\toevent{x}$ for $x \in X$.
For a set $I$, let $\extinputs$ be $I \cup \toevents$.

We write $A \hookrightarrow B$ for the set of partial functions from $A$ to $B$.
With $f \lceil A$ we denote the restriction of function $f$ to $\domof{f} \cap A$.
For arbitrary functions $f$ and $g$, $f [g]$ is the function with domain $\domof{f}$ that behaves like $f$
on $\domof{f} \setminus \domof{g}$ and like $g$ on $\domof{f} \cap \domof{g}$.

\begin{definition}
\label{def:MMT}
A \emph{Mealy machine with timers (MMT)} is a tuple
\\
$\M = (I, O, Q, q_0, \vars, \delta, \lambda, \remap)$, where
\begin{itemize}
\item
$I$ is a finite set of input events,
\item
$O$ is a finite set of outputs, containing a special default output $\Lambda$,
\item
$Q$ is a finite set of states,
\item
$q_0 \in Q$ is the initial state,
\item
$\vars$ maps each state $q \in Q$ to a finite set of timers $\varsof{q}$, with $\varsof{q_0} = \emptyset$,
\item
$\delta: Q \times \extinputs \hookrightarrow  Q$ is a transition function,
%with $\delta(q,i)$ defined iff $q \in Q$ and $i \in I \cup \{ \toevent{x} \mid x \in \varsof{q} \}$, 
\item
$\lambda: Q \times \extinputs \hookrightarrow O$ is an output function, 
\item
$\remap : Q \times \extinputs \hookrightarrow (X \hookrightarrow \natplus)$ is a timer initialization function.
Let $q \in Q$, $i \in \extinputs$, $q'=\delta(q,i)$ and $\rho=\remap(q,i)$. 
We require that $\rho$ is injective and $\varsof{q'} \setminus \varsof{q} \subseteq \domof{\rho} \subseteq\varsof{q'}$. Moreover
  if $i=\toevent{x}$, for some $x$, then $x \not\in \varsof{q'} \setminus \domof{\rho}$.
\end{itemize}
We require that input events are always enabled and timeout events are only enabled
for timers that are active in the current state:
\marginpar{Explain injectivity is required for determinism}
for $q \in Q$ and $i \in \extinputs$,  $\delta(q,i)$, $\lambda(q,i)$ and $\pi(q,i)$ are defined iff either
$i \in I$ or $i=\toevent{x}$, for some $x \in\varsof{q}$.
We write $q \xrightarrow{i/o,\rho} q'$ if $\delta(q,i) = q'$, $\lambda(q,i)= o$ and $\remap(q,i) = \rho$.
\end{definition}
The restart function $\remap$ determines how timers are affected when an event $i$ occurs in state $q$.
Basically, there are four things that may happen.
\marginpar{Add Venn diagram to illustrate situation.}
Let $q \in Q$, $i \in \extinputs$, $\delta(q,i)=q'$ and $\remap(q,i)=\rho$.
\begin{enumerate}
\item
If $x \in\varsof{q} \setminus \varsof{q'}$ then input $i$ \emph{stops} timer $x$.
\item
If $x \in \varsof{q'} \setminus \varsof{q}$ then $i$ \emph{starts} timer $x$ with value $\rho(x)$.
\item
If $x \in \varsof{q} \cap \domof{\rho}$ then $i$ \emph{restarts} timer $x$ with value $\rho(x)$.
\item
Finally, if $x \in \varsof{q'} \setminus \domof{\rho}$ then timer $x$ is \emph{unaffected} by $i$.
\end{enumerate}
Hence, when timer $x$ expires (i.e., event $\toevent{x}$ occurs) it is either stopped or restarted.

\paragraph{Semantics.}
The semantics of MMT $\M = (I, O, Q, q_0, \vars, \delta, \lambda, \remap)$ is defined via an infinite state transition system that describes all possible
configurations and transitions between them.
A \emph{valuation} is a partial function
$\tvals : X \hookrightarrow \realsplus$ that assigns nonnegative real numbers as values to timers.
We write $\Vals{Y}$ for the set of valuations with domain $Y \subseteq X$.
A \emph{configuration} of a MMT is a pair $(q,\tvals)$, where $q \in Q$ is a state and $\tvals\in\Vals{\varsof{q}}$ is a valuation.
The \emph{initial configuration} is the pair $(q_0, \tvals_0)$, where $\tvals_0$ is the empty function.
Valuations and configurations can be modified by the occurrence of events (inputs or timeouts) and delays.
If $\tvals$ is a valuation in which all timers
have a value of at least $d$, then $d$ units of time may pass. As a result this delay the value of all the timers is decremented by $d$.
Formally, we define for $\tvals, \tvals'$ valuations and delay $d \in \delays$,
\marginpar{The whole robustness analysis becomes easy/trivial if we assume $d>0$, because then 
a time delay precedes each input, allowing us to fidget with the timing of this input. Argument against this change is that
in a concurrent setting we may not exclude simulaneous inputs.}
\begin{eqnarray*}
\tvals \xrightarrow{d} \tvals' & \Leftrightarrow & [\domof{\tvals} = \domof{\tvals'} \wedge \forall x \in\domof{\tvals} : \tvals'(x) = \tvals(x) - d ].
\end{eqnarray*}
If the current valuation is $\tvals$, then a timeout event $\toevent{x}$ may occur only if $\tvals(x)=0$.
If an input or a timeout event occurs, a valuation is updated as specified by timer initialization function $\rho$.
The values of timers that are not affected by $\rho$ remain unchanged.
Formally, we define for $\tvals, \tvals'$ valuations, $i \in \extinputs$, $o \in O$ and $\rho \in X \hookrightarrow \natplus$,
\begin{eqnarray*}
\tvals \xrightarrow{i/o, \rho}  \tvals' & \Leftrightarrow & [ \domof{\tvals'} \setminus \domof{\tvals}  \subseteq \domof{\rho} \subseteq \domof{\tvals'} ~ \wedge\\
&& \tvals' =  \tvals'[\tvals][\rho] ~ \wedge \\
&& \forall x \in X : i=\toevent{x} \Rightarrow (\tvals(x) = 0 \wedge x \not\in\domof{\tvals'} \setminus \domof{\rho})].
\end{eqnarray*}
Transition predicates $\xrightarrow{d}$ and $\xrightarrow{i/o, \rho}$ can be easily lifted to configurations.
For all configurations $(q, \tvals)$, $(q', \tvals')$ of an MMT $\M$,
\[
\frac{q = q' \quad \tvals \xrightarrow{d} \tvals'}{(q,\tvals) \xrightarrow{d} (q',\tvals')}
\quad\quad
  \frac{q \xrightarrow{i/o,\remapinst} q' \quad \tvals \xrightarrow{i/o, \rho} \tvals'}{(q,\tvals) \xrightarrow{i/o} (q',\tvals')}
\]
A \emph{timed word} over inputs $\extinputs$ and outputs $O$ is a sequence
\begin{eqnarray*}
w & = &  (i_1, o_1, d_1) (i_2, o_2, d_2) \cdots (i_k, o_k, d_k),
\end{eqnarray*}
where each $i_j \in \extinputs$, each $o_j \in O$, and each $d_j \in \delays$.
A \emph{timed run} of $\M$ over $w$ is a sequence 
\begin{eqnarray*}
\alpha & = & C_0 \xrightarrow{d_1} C'_0 \xrightarrow{i_1/o_1} C_1 \xrightarrow{d_2} C'_1 \xrightarrow{i_2/o_2} C_2 \cdots
\xrightarrow{d_k} C'_{k-1} \xrightarrow{i_k/o_k} C_{k}
\end{eqnarray*}
of transitions between configurations $C_j, C'_j$ of $\M$, where $C_0$ is the initial configuration.
%Note that, since MMTs are deterministic (if we allow to observe the
%identities of timers in timeout events),
%for each timed word $w$ there exists at most one run over $w$.
To each timed run $\alpha$ we can associate a timed word by forgetting the configurations:
\begin{eqnarray*}
\timedword(\alpha) & = & (i_1, o_1, d_1) (i_2, o_2, d_2) \cdots (i_k, o_k, d_k).
\end{eqnarray*}
We say $w$ is a timed word of $\M$ if $\M$ has a timed run $\alpha$ with $w = \timedword(\alpha)$.

Two MMTs $\M$ and $\N$ with the same sets of inputs are \emph{timed equivalent}, denoted $\M \approx_{\mathit{timed}} \N$, iff 
they have the same sets of timed words.

\marginpar{Conjecture: Just being allowed to start just one timer on a transition does not reduce expressivity.}

\subsection{A product construction}
An \emph{untimed behavior} over inputs $I$, outputs $O$, and timers $Y \subseteq X$ is a sequence 
\begin{eqnarray*}
\beta & = & X_0 \xrightarrow{i_1/o_1, \rho_1} X_1  \xrightarrow{i_2/o_2, \rho_2} X_2 \cdots \xrightarrow{i_k/o_k, \rho_k} X_{k},
\end{eqnarray*}
where $X_0 \subseteq Y$ and, for each $j>0$,  $i_j \in \extinputs$, $o_j \in O$, $\rho_j \in X \hookrightarrow \natplus$, and
 $X_j \setminus X_{j-1}  \subseteq \domof{\rho_j} \subseteq X_j \subseteq Y$.
Moreover, if $i_j = \toevent{x}$, for some $j>0$, then $x \in X_{j-1}$ and $x \not\in X_j \setminus \domof{\rho_j}$.

An \emph{untimed run} of an MMT $\M$ is a sequence
\begin{eqnarray*}
\gamma & = & q_0 \xrightarrow{i_1/o_1, \rho_1} q_1  \xrightarrow{i_2/o_2, \rho_2} q_2 \cdots \xrightarrow{i_k/o_k, \rho_k} q_k
\end{eqnarray*}
of transitions of $\M$ that starts with the initial state $q_0$. 
To each untimed run $\gamma$ we can associate a corresponding untimed behavior by simply replacing all
states by their sets of timers:
\begin{eqnarray*}
\beh(\gamma) & = & \vars(q_0) \xrightarrow{i_1/o_1, \rho_1} \vars(q_1)  \xrightarrow{i_2/o_2, \rho_2} \vars(q_2) \cdots \xrightarrow{i_k/o_k, \rho_k} \vars(q_k).
\end{eqnarray*}
We say that $\beta$ is a untimed behavior of $\M$ if $\M$ has an untimed run $\gamma$ with $\beh(\gamma) = \beta$.
Note that the initial timer set of any untimed behavior of $\M$ is empty.

A \emph{timed behavior} over inputs $I$, outputs $O$, and timers $Y \subseteq X$ is an alternating sequence
\begin{eqnarray*}
\sigma & = & \tvals_0 \xrightarrow{d_1} \tvals'_0 \xrightarrow{i_1/o_1, \rho_1} \tvals_1 \xrightarrow{d_2} \tvals'_1 \xrightarrow{i_2/o_2, \rho_2} \tvals_2 \cdots
\xrightarrow{d_k} \tvals'_{k-1} \xrightarrow{i_k/o_k, \rho_k} \tvals_{k}
\end{eqnarray*}
of delay predicates and event predicates with, for each $j$,
$\tvals_j, \tvals'_j$ valuations
with $\domof{\tvals_j} = \domof{\tvals'_j} \subseteq Y$ and,
for each $j>0$,  $d_j \in \delays$, $i_j \in \extinputs$, $o_j \in O$, and $\rho_j \in Y \hookrightarrow \natplus$.
To each timed behavior $\sigma$ we can associate a corresponding untimed behavior by forgetting the time
delays and by replacing valuations by their domain:
\begin{eqnarray*}
\untime(\sigma) & = & \domof{\tvals_0} \xrightarrow{i_1/o_1, \rho_1} \domof{\tvals_1}  \xrightarrow{i_2/o_2, \rho_2} \domof{\tvals_2} \cdots \xrightarrow{i_k/o_k, \rho_k} \domof{\tvals_k}.
\end{eqnarray*}
We say that untimed behavior $\beta$ is \emph{feasible} if there exists a timed behavior $\sigma$ such that $\untime(\sigma) = \beta$.
We can also associate a timed word to timed behavior $\sigma$ by forgetting the valuations and the initialization functions:
\begin{eqnarray*}
\timedword(\sigma) & = & (i_1, o_1, d_1) (i_2, o_2, d_2) \cdots (i_k, o_k, d_k).
\end{eqnarray*} 
Let $\alpha$ be a timed run of an MMT $\M$: 
\begin{eqnarray*}
\alpha & = & (q_0, \tvals_0) \xrightarrow{d_1} (q_0, \tvals'_0) \xrightarrow{i_1/o_1} (q_1, \tvals_1) \xrightarrow{d_2} (q_1, \tvals'_1)  \cdots
 \xrightarrow{i_k/o_k} (q_k, \tvals_k).
\end{eqnarray*}
Then $\alpha$ can be projected both to an untimed run of $\M$
\begin{eqnarray*}
\untime (\alpha) & = & q_0 \xrightarrow{i_1/o_1, \rho_1} q_1  \xrightarrow{i_2/o_2, \rho_2} q_2 \cdots \xrightarrow{i_k/o_k, \rho_k} q_k
\end{eqnarray*}
(note that the $\rho_j$ are uniquely determined since $\M$ is deterministic) and to a timed behavior
\begin{eqnarray*}
\beh(\alpha) & = & \tvals_0 \xrightarrow{d_1} \tvals'_0 \xrightarrow{i_1/o_1, \rho_1} \tvals_1 \xrightarrow{d_2} \tvals'_1 \xrightarrow{i_2/o_2, \rho_2} \tvals_2 \cdots
\xrightarrow{d_k} \tvals'_{k-1} \xrightarrow{i_k/o_k, \rho_k} \tvals_{k}.
\end{eqnarray*}
Note that $\beh(\untime(\alpha))=\untime(\beh(\alpha))$ and $\timedword(\alpha) = \timedword(\beh(\alpha))$.
Thus the diagram of Figure~\ref{fig:diagram}, which summarizes the various types of runs and behaviors that we consider, commutes.
\begin{figure}[h]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.5cm,main node/.style={circle,draw,font=\sffamily\large\bfseries}]
  \node[state,align=center] (1) {timed \\ runs of\\ $\M$};
  \node[state,align=center] (2) [below of=1] {untimed \\ runs of\\ $\M$};
  \node[state,align=center] (3) [right of=1] {timed\\ behaviors};
  \node[state,align=center] (4) [right of=2] {untimed\\ behaviors};
  \node[state,align=center] (5) [above of=3] {timed \\words};

  \path[every node/.style={font=\sffamily\scriptsize}]
    (1) edge  node {$\untime$} (2)
        edge  node {$\beh$} (3)
        edge  node {$\timedword$} (5)
    (2) edge  node {$\beh$} (4)
    (3) edge  node {$\untime$} (4)
        edge  node {$\timedword$} (5);
\end{tikzpicture}
\caption{Functions relating different types of runs and behaviors}
\label{fig:diagram}
\end{figure}
Conversely, if $\gamma$ is an untimed run  of $\M$ and $\sigma$ is a timed behavior such that $\beh(\gamma) = \untime(\sigma)$,
then there exists a unique timed run $\alpha$ of $\M$ with $\untime(\alpha) = \gamma$ and $\beh(\alpha) = \sigma$.
We refer to $\alpha$ as $\run(\gamma,\sigma)$.
\marginpar{Is this a pullback?}

\subsection{Untimed semantics}
We would, intuitively, like to let the untimed semantics of an MMT $\M$ be the set of its feasible untimed behaviors.
However, it would then depend heavily on the names of the timers. Therefore, we define an equivalence relation
on untimed behaviors, which deems two untimed behaviors equivalent if there is a consistent renaming of timers that transforms
the one into the other.

Let $X_0,\ldots, X_k$ be a sequence of sets $X_j \subseteq X$ of timers.
An \emph{isomorphism} for $X_0,\ldots, X_k$ is a sequence $f = f_0 ,\ldots, f_k$ of bijections $f_j : X_j \rightarrow Y_j$ such that,
for all $j>0$, $f_j \lceil X_{j-1} = f_{j-1} \lceil X_j$ and $f_j (X_j \setminus X_{j-1}) \cap Y_{j-1} = \emptyset$.
If $f = f_0 ,\ldots, f_k$ is an isomorphism with $f_j : X_j \rightarrow Y_j$ and
\begin{eqnarray*}
\beta & = & X_0 \xrightarrow{i_1/o_1, \rho_1} X_1  \xrightarrow{i_2/o_2, \rho_2} X_2 \cdots \xrightarrow{i_k/o_k, \rho_k} X_{k}
\end{eqnarray*}
is an untimed behavior then $f(\beta)$ is the untimed behavior given by
\begin{eqnarray*}
f(\beta) & = & Y_0 \xrightarrow{i'_1/o_1, \rho'_1} Y_1  \xrightarrow{i'_2/o_2, \rho'_2} Y_2 \cdots \xrightarrow{i'_k/o_k, \rho'_k} Y_{k},
\end{eqnarray*}
where 
$i'_j = i_j$ if $i_j \in I$ and $i'_j = \toevent{f_{j-1}(x)}$ if $i_j = \toevent{x}$, for $j>0$ and $x \in X_{j-1}$, and
$\rho'_j$ is the function with $\domof{\rho'_j} = f(\domof{\rho_j})$ and
$\rho'_j(x) = \rho_j ( f_j^{-1}(x))$, for all $j>0$ and $x\in\domof{\rho'_j}$.
(The reader may check that $f(\beta)$ is an untimed behavior indeed.)
Two untimed behaviors $\beta$ and $\beta'$ are \emph{isomorphic} if there exists an isomorphism $f$ such that
$\beta' = f(\beta)$.
Two sets of untimed behaviors $A$ and $B$ are \emph{isomorphic} if for each untimed behavior of $A$ there is an isomorphic untimed behavior in $B$,
and vice versa.

Isomorphisms are lifted to timed behaviors in the obvious way. If $f = f_0 ,\ldots, f_k$ is an isomorphism and
\begin{eqnarray*}
\sigma & = & \tvals_0 \xrightarrow{d_1} \tvals'_0 \xrightarrow{i_1/o_1, \rho_1} \tvals_1 \xrightarrow{d_2} \tvals'_1 \xrightarrow{i_2/o_2, \rho_2} \tvals_2 \cdots
\xrightarrow{d_k} \tvals'_{k-1} \xrightarrow{i_k/o_k, \rho_k} \tvals_{k}
\end{eqnarray*}
is a timed behavior with $\domof{\tvals_j} = \domof{\tvals'_j} = \domof{f_j}$, for all $j$, then $f(\sigma)$ is
the timed behavior
\begin{eqnarray*}
f(\sigma) & = & \lambda_0 \xrightarrow{d_1} \lambda'_0 \xrightarrow{i'_1/o_1, \rho'_1} \lambda_1 \xrightarrow{d_2} \lambda'_1 \xrightarrow{i'_2/o_2, \rho'_2} \lambda_2 \cdots
\xrightarrow{d_k} \lambda'_{k-1} \xrightarrow{i'_k/o_k, \rho'_k} \lambda_{k}
\end{eqnarray*}
where $i'_j$ and $\rho'_j$ are defined in the same way as for untimed behaviors, and
$\lambda_j = \kappa_j \circ f_j^{-1}$ and $\lambda'_j = \kappa'_j \circ f_j^{-1}$, for all $j$.
Two timed behaviors $\sigma$ and $\sigma'$ are \emph{isomorphic} if there exists an isomorphism $f$ such that
$\sigma' = f(\sigma)$.
Since an isomorphism only renames variables, which do not appear in timed words, 
isomorphic timed behaviors induce identical timed words: $\sigma' = f(\sigma) \Rightarrow \timedword(\sigma') = \timedword(\sigma)$.

The following lemmas follow directly from the definitions:
\begin{lemma}
\label{lemma isomorphism}
Let $\sigma$ be a timed behavior and let $f$ be an isomorphism for $\sigma$.
Then $\untime(f(\sigma)) = f(\untime(\sigma))$.
\end{lemma}
\begin{lemma}
If untimed behaviors $\beta$ and $\beta'$ are isomorphic, then $\beta$ is feasible iff $\beta'$ is feasible.
\end{lemma}

Two MMTs $\M$ and $\N$ with the same sets of inputs are \emph{untimed equivalent}, denoted $\M \approx_{\mathit{untimed}} \N$, iff their sets of feasible untimed behaviors are isomorphic.

\marginpar{Here an extensive example!}

\begin{theorem}
\label{untimedimpliestimed}
$\M \approx_{\mathit{untimed}} \N$
implies
$\M \approx_{\mathit{timed}} \N$.
\end{theorem}
\begin{proof}
Assume $\M \approx_{\mathit{untimed}} \N$ and $w$ is a timed word of $\M$.
Since $\approx_{\mathit{timed}}$ is symmetric, it suffices to prove that $w$ is a timed word of $\N$.
Since $w$ is a timed word of $\M$,
there exists a timed run $\alpha$ of $\M$ with $\timedword(\alpha) = w$. 
Let $\sigma = \beh(\alpha)$ and $\beta = \untime(\sigma)$. 
Then $\beta$ is a feasible untimed behavior of $\M$ and $\timedword(\sigma) = w$.
Since  $\M \approx_{\mathit{untimed}} \N$, there exists an isomorphism $f$ such that 
$\beta' = f(\beta)$ is a feasible untimed behavior of $\N$.
Hence $\N$ has an untimed run $\gamma'$ such that $\untime(\gamma') = \beta'$.
Let $\sigma' = f(\sigma)$.
By Lemma~\ref{lemma isomorphism}, $\sigma'$ is a timed behavior with 
$\untime(\sigma') = \untime(f(\sigma)) = f(\untime(\sigma)) = f(\beta) = \beta'$.
Since $\beh(\gamma') = \untime(\sigma') = \beta'$, $\N$ has a timed run $\alpha' = \run(\gamma',\sigma')$ with
$\beh(\alpha') = \sigma'$.
Note that $\timedword(\alpha') = \timedword(\sigma') = \timedword(f(\sigma)) = \timedword(\sigma) = w$.
Hence $w$ is a timed word of $\N$, as required.
\end{proof}

The converse of Theorem~\ref{untimedimpliestimed} does not hold: if two MMTs are timed equivalent then they need not
be untimed equivalent. This is due to the fact that an MMT may have timers that are always stopped or restarted before
they expire.
\marginpar{Give some examples here; timer liveness is not enough! Need: at most one timer started on each transition, timer liveness, and some robustness / fidget space.}

Let $\M$ be an MMT. Then we say that $\M$ is \emph{timer live} if, for each time run $\alpha$ and for each timer $x$
\marginpar{How can we decide timer liveness?}
of the final configuration of $\alpha$, there exists an extension $\alpha'$ of $\alpha$ in which timer $x$ 
remains unaffected until it expires.

Alternative: 
\marginpar{Alternative definition is more general and it should be easier to decide. Need to  reorder paper.}
Let $\M$ be an MMT. Then we say that $\M$ is \emph{timer live} if, for each feasible untimed behavior $\beta$ with $\Last{\beta} = Y$ and for each timer $x \in Y$, there exists an untimed behavior $\beta'$ with $\Head{\beta'} = Y$ that only contains
transitions that leave $x$ unaffected such that $x$ is expirable after $\beta$.

\begin{theorem}
\label{timedimpliesuntimed}
Suppose that $\M$ and $\N$ are timer live MMTs in which at most one timer is started on each transition. Then
$\M \approx_{\mathit{timed}} \N$
implies
$\M \approx_{\mathit{untimed}} \N$.
\end{theorem}
\begin{proof}
Suppose that $\M \approx_{\mathit{timed}} \N$.
Let $\beta$ be a feasible untimed behavior of $\M$.
By induction on the number of events in $\beta$, we prove that $\N$ has a feasible untimed behavior that is isomorphic to $\beta$.
Since $\approx_{\mathit{untimed}}$ is symmetric, this suffices to prove the theorem.

Induction base. If $\beta$ contains $0$ events then it consists of the empty set of variables $\emptyset$.
Since $\emptyset$ is a feasible untimed behavior of any MMT, $\beta = \emptyset$ is a feasible untimed behavior of $\N$, as required.

Induction step. Suppose $\beta$ contains $k+1$ events:
\begin{eqnarray*}
\beta & = & X_0 \xrightarrow{i_1/o_1, \rho_1} X_1  \xrightarrow{i_2/o_2, \rho_2} X_2 \cdots \xrightarrow{i_k/o_k, \rho_k} X_{k}
 \xrightarrow{i_{k+1}/o_{k+1}, \rho_{k+1}} X_{k+1}.
\end{eqnarray*}
Let $\beta_k$ be the prefix of $\beta$ containing $k$ events. Then $\beta_k$ is also a feasible untimed behavior and thus, by
induction hypothesis, there exists a feasible untimed behavior
\begin{eqnarray*}
\beta' & = & Y_0 \xrightarrow{i_1/o_1, \tau_1} Y_1  \xrightarrow{i_2/o_2, \tau_2} Y_2 \cdots \xrightarrow{i_k/o_k, \tau_k} Y_{k}
\end{eqnarray*}
of $\N$ that is isomorphic to $\beta_k$. This means
there exist bijections $f_j : X_j \rightarrow Y_j$, for all $j \leq k$, such that, for all $j>0$, $\domof{\tau_j} = f_j(\domof{\rho_j})$ and, for all $x \in\domof{\rho_j}$,
$\rho_j(x) = \tau_j (f_j(x))$ and, for all $x \in X_j \setminus \domof{\rho_j}$, $f_j(x) = f_{j-1}(x)$.
\end{proof}

\subsection{Reachability analysis}
For any nonempty sequence $\sigma$, $\Head{\sigma}$ denotes the first element of $\sigma$, $\Tail{\sigma}$ denotes the sequence obtained by removing the first element from $\sigma$, and $\Last{\sigma}$ denotes the last element of $\sigma$.
Suppose $\beta, \beta'$ are untimed behaviors over $I$, $O$ and $Y$ such that $\Last{\beta} = \Head{\beta'}$.
Then $\beta \cdot \beta'$, the \emph{sequential composition} of $\beta$ and $\beta'$, is the untimed behavior $\beta \Tail{\beta'}$.
Behavior $\beta$ is a \emph{prefix} of untimed behavior $\gamma$ if there exists an untimed behavior $\beta'$ such that $\gamma = \beta \cdot \beta'$.

It is not difficult to translate an MMTs to a timed automaton \cite{AD94,BengtssonY03} that accepts the same timed words.
Through such a translation, verification and analysis tools for timed automata, such as Uppaal \cite{Uppaal4.0}
become available for MMTs.
MMTs are strictly less expressive than timed automata. MMTs, for instance, do not contain time deadlocks or zeno loops that
may prevent time from progressing.

MMTs have infinitely (in fact even uncountably) many configurations and it is thus necessary to use symbolic representations
for reachability analysis. Given an untimed behavior $\beta$ we want to compute its effect on a set of valuations. 
If $\beta =X_0$ and $K \subseteq\Vals{X_0}$ then we define $\Post_{\beta}(K) = K$.
If $\beta = X_0 \xrightarrow{i_1/o_1, \rho_1} X_1$ and
$K \subseteq\Vals{X_0}$ then
\begin{eqnarray*}
\Post_{\beta}(K) & = & \{ \tvals'' \in\Vals{X_1} \mid \exists \tvals \in K \exists d >0 \exists \tvals' \in\Vals{X_0} :
 \tvals \xrightarrow{d} \tvals' \xrightarrow{i_1/o_1, \rho_1} \tvals'' \}.
\end{eqnarray*}
The definition of $\Post_{\beta}(K)$ is extended inductively to arbitrary $\beta$ by 
$\Post_{\gamma \cdot \gamma'}(K) = \Post_{\gamma'} (\Post_{\gamma}(K))$, where $\gamma \cdot \gamma'$ is the decomposition of
$\beta$ into an untimed behavior $\gamma$ of length one and an untimed behavior $\gamma'$.
We write $\Post_{\beta}$ as abbreviation for $\Post_{\beta}(\Vals{\Head{\beta}})$.

For any untimed behavior $\beta$, the set $\Post_{\beta}$ can be symbolically represented and computed using a Difference Bound Matrices (DBMs)
 \cite{Di89},  as the transition predicates $\xrightarrow{d}$ and $\xrightarrow{i_1/o_1, \rho_1}$ can be easily decomposed 
into elementary operations that have been defined
on DBMs such as reset, conjunction, and delay successors \cite{BengtssonY03}.

Since emptiness of DBMs is also decidable, the following lemma allows us to compute whether or not an untimed behavior is feasible.

\begin{lemma}
Suppose $\beta$ is an untimed behavior. Then $\beta$ is feasible iff $\Post_{\beta} \neq \emptyset$.
\end{lemma}
\begin{proof}
Straightforward by induction on the length of $\beta$.
\end{proof}

The next four lemma's will be used in the following subsection.

\begin{lemma}
\label{lemma: feasibility concatenation}
Suppose $\beta, \beta'$ are untimed behaviors with
% $\Last{\beta} = \Last{\beta'} = X_1$ and 
$\Post_{\beta} = Post_{\beta'}$. Let $\gamma$ be any untimed behavior.
Then $\beta \cdot \gamma$ is feasible iff $\beta' \cdot \gamma$ is feasible.
\end{lemma}

\begin{lemma}
\label{lemma finitely many zones}
Let $\M$ be an MMT. Then the set
$\{ \Post_{\beta} \mid \beta \mbox{ is a feasible untimed behavior of } \M \}$ is finite.
\end{lemma}
\begin{proof}
All the sets $\Post_{\beta}$ can be represented using DBMs. Since an MMT only has a finite number of timers that can only be set to a finite number of integer values. Since in an MMT the values of timers can only decrease, only finitely many numbers may
appear in the DBM's that represent the sets $\Post_{\beta}$. Thus all the sets $\Post_{\beta}$ can be represented by a finite
collection of DBMs.
\end{proof}

\begin{lemma}
Suppose $\beta$ is a feasible untimed behavior and $Y \xrightarrow{i/o, \rho} Y'$ is an untimed behavior,
with $Y = \Last{\beta}$ and $i \in I$.
Then $\beta \xrightarrow{i/o, \rho} Y'$ is a feasible untimed behavior.
\end{lemma}

Let $\beta$ be a feasible untimed behavior and let $x \in X$ be a timer. Then we say that $x$ is \emph{expirable} after $\beta$
if there exists a valuation in $\Post_{\beta}$ in which $x$ is minimal.

\begin{lemma}
Suppose $\beta$ is a feasible untimed behavior and $Y \xrightarrow{\toevent{x}/o, \rho} Y'$ is an untimed behavior 
with $Y = \Last{\beta}$.
Then $x$ is expirable after $\beta$ iff $\beta \xrightarrow{\toevent{x}/o, \rho} Y'$ is feasible.
\end{lemma}

\subsection{Myhill-Nerode}  
We present a variant of the famous Myhill-Nerode theorem for MMTs.
We will use this theorem as a basis for an automata learning algorithm for MMTs.

\begin{definition}
Let $S$ be a set of feasible untimed behaviors over $I$, $O$ and $Y$. Then $S$ is
\begin{itemize}
\item
\emph{prefix closed}: $\beta \beta' \in S \Longrightarrow \beta \in S$,
\item
\emph{behavior deterministic}:
$\beta \xrightarrow{i/o_1, \rho_1} X_1 \in S \wedge \beta \xrightarrow{i/o_2, \rho_2} X_2 \in S \Longrightarrow o_1 = o_2 \wedge \rho_1 = \rho_2 \wedge X_1 = X_2$,
\item
\emph{input complete}:
$\beta \in S \wedge i \in I \Longrightarrow \exists o, \rho, Y : \beta \xrightarrow{i/o, \rho} Y \in S$,
\item
\emph{timeout complete}:
$\beta \in S \wedge x \mbox{ expirable after } \beta \Longrightarrow
\exists o, \rho, Y: \beta \xrightarrow{\toevent{x}/o, \rho} Y \in S$.
\end{itemize}
Behaviors $\beta, \beta' \in S$ are \emph{equivalent} for $S$, notation $\beta \equiv_S \beta'$, iff 
$\Post_{\beta} = \Post_{\beta'}$ and for any observation
$\gamma$ over $I$, $O$ and $Y$, $\beta \cdot \gamma \in S \Leftrightarrow \beta' \cdot \gamma \in S$.
We write $[\beta]$ to denote the equivalence class of $\beta$ with respect to $\equiv_S$.
\end{definition}

\begin{theorem}
Let $S$ be a set of feasible untimed behaviors over finite sets of inputs $I$, outputs $O$, and timers $Y$.
Then $S$ is the set of feasible untimed behaviors of an MMT $\M$ iff $S$ is nonempty, all untimed behaviors in $S$
start with the empty set of timers, $S$ is prefix closed, behavior deterministic, input complete, timeout complete,
and $\equiv_S$ has only finitely many equivalence classes (finite index).
\end{theorem}
\begin{proof}

``$\Rightarrow$'' Let $\M$ be an MMT and let $S$ be the set of its feasible untimed behaviors.
Then it is immediate from the definitions that $S$ is nonempty, all untimed behaviors in $S$
start with the empty set of timers, $S$ is prefix closed, behavior deterministic, input complete, and timeout complete.
Suppose that feasible untimed behaviors $\beta$ and $\beta'$ lead to the same state $q$ and moreover $\Post_{\beta} = \Post_{\beta'}$.
Then, 
by Lemma~\ref{lemma: feasibility concatenation},
for any untimed behavior $\gamma$, $\beta \cdot \gamma \in S \Leftrightarrow \beta' \cdot \gamma \in S$, and thus
$\beta \equiv_S \beta'$.
Since $\M$ only has finitely many states and by Lemma~\ref{lemma finitely many zones} the set
$\{ \Post_{\beta} \mid \beta \mbox{ is a feasible untimed behavior of } \M \}$ is finite, this means that
$\equiv_S$ has finite index.

``$\Leftarrow$'' Suppose $S$ is nonempty, etc.
We define MMT $\M = (I, O, Q, q_0, \vars, \delta, \lambda, \remap)$ as follows:
\begin{itemize}
\item
$Q$ is the set of equivalence classes of $\equiv_S$,
\item
$q_0 = [\emptyset]$. (Note that $\emptyset \in S$ since $S$ is nonempty, prefix closed, and all untimed behaviors in $S$ start
with the empty set of timers.)
\item
$\varsof{[\beta]} = \Last{\beta}$.
\item
Let $\beta \in S$ and $i \in I$. Then, since $S$ is both input complete and behavior deterministic, there exist unique
$o$, $\rho$ and $Y$ such that $\beta' = \beta \xrightarrow{i/o, \rho} Y \in S$.
We define $\delta([\beta],i) = [\beta']$, $\lambda([\beta],i) = o$, and $\remap([\beta],i) = \rho$.
\item
Assume $\beta \in S$ and $x\in \Last{\beta}$ expirable after $\beta$. 
Then, since $S$ is both input complete and behavior deterministic, there exist unique
$o$, $\rho$ and $Y$ such that $\beta' = \beta \xrightarrow{\toevent{x}/o, \rho} Y \in S$.
We define $\delta([\beta],\toevent{x}) = [\beta']$, $\lambda([\beta],\toevent{x}) = o$, and $\remap([\beta],\toevent{x}) = \rho$.
\item
Assume $\beta \in S$ and $x \in \Last{\beta}$ not expirable after $\beta$.
We define $\delta([\beta],\toevent{x}) = [\beta]$, $\lambda([\beta],\toevent{x}) = \Lambda$, and $\remap([\beta],\toevent{x}) = \rho_0$, where $\domof{\rho_0} = \emptyset$.
\end{itemize}
It is routine to verify that $M$ is a well-defined MMT whose set of feasible untimed behaviors equals $S$.
\end{proof}



\section{Automata Learning for MMTs}
In this section, we present an algorithm for automata learning for MMTs.
It is based on the Nerode equivalence $\equiv_{\M}$, which is used to adapt
the standard paradigm for automata learing, using $L^*$, which is also adapted
to register automata in~\cite{CasselHJS16}. 

Thus, two tasks must be accomplised in order to design the algorithm.
\begin{itemize}
  \item
    One task is to infer untimed traces of am MMT.
    This is done by supplying membership queries, in the form of inputs
    with specific timing.
\item
  One task is to define suitable approximations of $\equiv_\M$, which are
  based on finite sets of suffixes. We must determine how to define suitable
  finite sets of suffix traces, which are used to define overapproximations
  of $\equiv_\M$.
\end{itemize}
We assume that we can observe
exact timing of events and that we can observe whenever a timeout event
happens. We cannot directly observe the setting of timers, or the identity
of the timer in a timeout event. However, whenever a timeout event, we
can infer where it was set, by supplying a small sequence of membership queries
with slightly perturbed timing. This is a consequence of the fact that we
assume MMTs to be robust, implying that we can always include ``slack'' in
the timing of inputs. The normalized name of the timer follows after inferring
in which transition it was set.

Let us begin with the second task.
Intuitively, we are looking for a mechanism for characterizing a finite
set of suffixes, so that we can adapt the definition of
$\uttrace \equiv^{\timerequiv} \uttrace'$ to consider specific subsets of
suffixes. The natural way to do this is, like~\cite{Nie03}, to define
finite sets of input sequences. In our setting, a complication is that
input sequences include timer events, of form $\toevent{x}$, and that
after different traces, timer events with different timers may or may
not be enabled. We solve this complication by omitting the
identity of the timer $x$ in input sequences that characterize suffixes.

Let an \emph{input prefix} be a sequence of extended inputs.
For a trace $\uttrace$, let $\pinpof{\uttrace}$ be the sequence of its
inputs an timer events.
Let a \emph{timeout symbol} be of form $\tosymbol$, i.e., a
timer event without any clock.
Let an \emph{input suffix} be a sequence of inputs and timeout symbols.
For a suffix trace $\strace$, let $\sinpof{\strace}$ be the sequence
of inputs and timeout symbols in $\strace$, i.e., $\sinpof{\strace}$ is the
sequence of extended inputs, but with timers removed from timer events.

A central mechanism in our active learning algorithm is a procedure which
takes  an input prefix $u$ and an input suffix $v$ and return the set of
untimed traces of form $\uttrace\conc\strace$ such that
$\pinpof{\uttrace} = u$ and $\sinpof{\strace} = v$. We must here take into
consideration that we may not be able to observe all timer settings of the
SUT; only those timer settings that can actually expire sometime during
$\uttrace\conc\strace$ can actually be observed.
This may further depend on the timing of transitions
in $\uttrace\conc\strace$.

%% Let us now consider the issue that timeout events are not always
%% enabled.
%% Consider a trace $u$ of $\M$, and assume that timer $x$ is set in the
%% $i$th event of $u$. Then, in each state the corresponding timeout even
%% $\toevent{x}$ may or may not be enabled; this may
%% further depend on the timing of events in $u$, including
%% the timing of events that precede the $i$th event.
%% This motivates the following definitions.

Motivated by these considerations,
let $\uttrace = \tuple{i_1,o_1,\remapinst_1}\cdots\tuple{i_n,o_n,\remapinst_n}$.
We say that $\uttrace$ is {\em feasible} if 
there is a corresponding timed word
$\tword = (i_1, o_1, t_1) \cdots (i_n, o_n, t_n)$ for some $\vect tn$.
We then say that $\tword$ is {\em derived} from $\uttrace$.
Let $\expirable(\uttrace)$ be the set of timers $x$ such that
$\tuple{i_1,o_1,\remapinst_1}\cdots\tuple{i_n,o_n,\remapinst_n}
\tuple{\toevent{x},o_{n+1},\remapinst_{n+1}}$
is feasible for some $o_{n+1}$, $\remapinst_{n+1}$.
For $u = \pinpof{\uttrace}$ we say that $u$ is feasible iff $\uttrace$ is
feasible, and define $\expirable(u) = \expirable(\uttrace)$.

%% For a sequence $u = i_1 \cdots i_n$, define $\uttraceof{u}$ as the normalized
%% trace $\tuple{i_1,o_1,\remapinst_1}\cdots\tuple{i_n,o_n,\remapinst_n}$
%% if it exists, otherwise $\uttraceof{u} = \bot$. We say that $u$ is {\em feasible}
%% if $\uttraceof{u}$ is defined and is feasible. Define
%% $\expirable(u)$ to be $\expirable(\uttraceof{u})$.
%% It follows that $u = i_1 \cdots i_n$ is feasible if and only if whenever
%% $i_k$ is a timeout event $\toevent{x}$ for some $k$ with $1 < k \leq n$, then
%% $x \in \expirable(i_1 \cdots i_{k-1})$.
%% We will later present a technique for inferring the set $\expirable(u)$.

\paragraph{Membership Queries}
The procedure for inferring untimed traces will utilize membership queries.
We will slightly adapt the notion of membership query to make it convenient
in our current setting.

A {\em membership query} is an alternating sequence
$t_1i_2t_2i_2 \cdots t_ni_nt_{n+1}$ of delays and inputs in $\extinputs$.
The response to a membership query is either
\begin{itemize}
\item
  a sequence $o_1 o_2 \cdots o_n$ of outputs in $O$, meaning that there is
  a corresponding timed word $(i_1, o_1, t_1) \cdots (i_n, o_n, t_n)(i_{n+1}, o_{n+1}, t_{n+1})$ for some $i_{n+1}$, $o_{n+1}$, $t_{n+1}'$ with $t_{n+1} \leq t_{n+1}'$,
  or
\item
  a timeout event after some prefix $t_1i_2t_2i_2 \cdots t_{k-1}i_{k-1}t_{k}'$
  where $k \leq n+1$ and $t_k' \leq t_k$, implying that  there is
  a corresonding timed word $(i_1, o_1, t_1) \cdots (\toevent{x}, o_k, t_k')$
  for some timer $x$. By the assumption of robustness, it is easy to
  determine where the timer $x$ was set. Therefore the response to the
  membership query is the index $k$ and the normalized timer name
  $\timerof jp$, or
\item
  a {\em missing timer event} after some prefix
  $t_1i_2t_2i_2 \cdots t_{k-1}i_{k-1}t_{k}$, implying that input $i_k$, of
  form $\toevent{x}$, does not occur at the intended time.
\end{itemize}

\paragraph{Inferring traces}
We can now present a central procedure of our learning algorithm,
which is one that 
takes a feasible input prefix $u$ and an input suffix $v$ and returns the set of
feasible (normalized) untimed traces of form $\uttrace\conc\strace$ such that
$\pinpof{\uttrace} = u$ and $\sinpof{\strace} = v$.
%% restricted to the set of timers that are in
%% $\expirable(i_1 \cdots i_{k})$ for some $k \leq n$.
We assume that names of timers are normalized.

%% Consider a trace 
%% $\tuple{i_1,o_1,\remapinst_1}\cdots\tuple{i_n,o_n,\remapinst_n}$.
%% and let 
%% $w = (i_1, o_1, t_1) \cdots (i_n, o_n, t_n)$ be a corresonding timed word.
%% We introduce the following canonical naming convention for timers.
%% A timer which is set to $p$ at transition $j$ (i.e., in response to
%% input $i_j$ is given the name $\timerof jp$. This means that
%% for a timer $\timerof jp$ we have
%% $\remapinst_j(\timerof jp) = p$, and that 
%% $\timerof jp \in \remapinst_k$ only if $j \leq k$ and $\timerof jp$ has
%% not expired at or before $i_k$, and then 
%% $\remapinst_k(\timerof jp) = \timerof jp$ if $j < k$.
%% We also extend $w$ by a delay $t_{n+1} \in \realsplus$, which intuitively
%% represents that time $t_{n+1}$ elapses after the trace; such a delay
%% may be observed only if it is not interrupted by a timeout event.


%% For each timer setting in the trace, i.e., each occurrence of
%% a timer  $x \in \domof{\remapinst_i}$ with  $\remapinst_i(x) \in \natplus$,
%% defined the constraint $\constrof{\word}$ as
%% \begin{itemize}
%% \item
%%   if $i_k$ is the timeout event $\toevent{x}$, then
%%   $\constrof{\word}$ is $\delay{i}{k}= \remapinst_i(x)$,
%% \item
%%   if the trace includes no timeout event $\toevent{x}$, then
%%   $\constrof{\word}$ is $\delay{i}{(n+1)} \leq \remapinst_i(x)$.
%% \end{itemize}
%% Define $\constrof{\word}$ as
%% the conjunction of $\constrof{\word}$ for all timer settings in the trace.

The procedure must find all ways to instantiate the timeout symbols in $v$
with actual timers to obtain a feasible instantiation of $u\conc v$, and for
each such instantiation determine the set of timers that may expire after some
prefix, and how they are manipulated.

Our procedure considers increasing prefixes $z$ of extended inputs that
instantiate some prefix of $u \conc v$. For each such prefix, it
determines the set $\expirable(z)$, the constraint $\constrof{z}$
under which $z$ can be performed without any succeeding timer event, 
the timers that are in $\expirable(z')$ for some prefix $z'$ of $z$, and
their manipulation.

The procedure performs repeated membership queries for selected values
of $\vect{t}{n+1}$, and gradually adds new timers to the word together
with constraints on $\vect{t}{n+1}$ induced by these timers.

Let $\delay{j}{k}$ denote $t_{j+1} + t_{j+2} + \cdots + t_k$.
%% This means that $\remapinst_j(\timerof jp) = p$, and that 
%% $\remapinst_l(\timerof jp) = \timerof jp$ if $j < l < k$.
%% This means that $\timerof jp \in \domof{\remapinst_l}$ iff
%% $j \leq l < k$, where $\remapinst_j(\timerof jp) = p$ and
%% $\remapinst_l(\timerof jp) = \timerof jp$ for $j < l < k$.
%% Initially, $\constrof{\word}$ is the conjunction of the constraints of form
%% $\delay{j}{k}=m$ for each $i_k$ of form is $\toevent{\timerof jp}$.

%% The procedure considers prefixes in increasing order. For each input prefix
%% $z$, it
%% \begin{itemize}
%% \item determines all timers that are in $\expirable(z)$,
%% \item gradually builds a constraint $\constrof{z}$ under which $z$ can
%%   be performed without interruption by unexpected timer events,
%% \item
%%   gradually builds the mappings $\remapinst_{z'}$ for prefixes $z'$ of $z$.
%% \end{itemize}

\medskip
\noindent{\bf Algorithm} \textsl{Infer-Traces.}
\begin{description}
\item[Input:] (normalized) feasible input prefix $u$ and input suffix $v$,
\item[Returns:] set of (normalized) traces
$\uttrace\conc\strace$ such that
$\pinpof{\uttrace} = u$ and $\sinpof{\strace} = v$, together with
  constraint $\constrof{\uttrace\conc\strace}$ on derived timed words.
\item[Initialization:]
    Let $z = \emptyword$, let $\constrof{z} = \true$;
\item[Return:]
    $\textsc{Infer-Traces}(\emptyword,\emptyword,\true)$
%%     \begin{itemize}
%% \item initialize $\vect{\remapinst}n$ by letting
%%     $\timerof jp \in \domof{\remapinst_l}$ iff $i_k$ is $\toevent{\timerof jp}$
%%     with $j \leq l < k$; let $\remapinst_j(\timerof jp) = p$ and
%%     $\remapinst_l(\timerof jp) = \timerof jp$ for $j < l < k$;
%% \item let $\constrof{\uttrace}$ be
%%     the conjunction of the constraints of form
%% $\delay{j}{k}=p$ for each $i_k$ of form $\toevent{\timerof jp}$.
%%     \end{itemize}
\end{description}
\medskip
\noindent{\bf Function} $\textsc{Infer-Traces}(z,\uttrace,\constrof{\uttrace})$;
\begin{enumerate}
\item
  let $z = i_1 \cdots i_m$;
  let $\uttrace = \tuple{i_1,o_1,\remapinst_1}\cdots\tuple{i_m,o_m,\remapinst_m}$;
\item
  {\bf for} each index $k = 1, \ldots , m$ {\bf do}:
     \qquad \textit{// find all timers in $\expirable(z)$}
  \begin{enumerate}
  \item
    find $\vect t{{m+1}}$ that maximizes $\delay{k}{(m+1)}$ given
    $\constrof{\uttrace}$;
  \item
    supply membership query $t_1i_2t_2i_2 \cdots t_mi_mt_{m+1}$;
  \item
    {\bf if} unexpected timeout $\toevent{\timerof jp}$ occurs within at most
    $t_{m+1}$ after $i_m$:
    \begin{enumerate}
    \item
      add $\timerof jp$ to $\domof{\remapinst_l}$ iff
$j \leq l \leq m$, where $\remapinst_j(\timerof jp) = p$ and
      $\remapinst_l(\timerof jp) = \timerof jp$ for $j < l \leq m$;
    \item
      Add conjunct 
      $\delay{j}{(m+1)} \leq p$ to $\constrof{\uttrace}$;
      \todobj{should it be $\delay{j}{(m+1)} < p$?}
    \item if $k \neq j$ go to (a);
    \end{enumerate}
    {\bf else} do nothing;
  \end{enumerate}
  {\bf od}
\item
  {\bf if} $\lengthof{z} = \lengthof{u} + \lengthof{v}$ {\bf return}
  $\tuple{\uttrace,\constrof{\uttrace}}$;
\item
  {\bf if} $i_{m+1} \in \extinputs$:
  \[  \textbf{return } \textsc{Infer-Traces}(zi_{m+1},\uttrace\tuple{i_{m+1},o_{m+1},\emptyset},\phi')
  \]
  where $\phi'$ is $\constrof{\uttrace}$ if $i_{m+1} \in I$, otherwise, if
  $i_{m+1} = \toevent{\timerof jp}$, it is obtained from $\constrof{\uttrace}$
  by replacing $\delay{j}{(m+1)} \leq p$ by $\delay{j}{(m+1)} = p$.
  \item
  {\bf else} \hspace*{4cm} \textit{// \ $i_{m+1}$ is the timeout symbol}
    \[
    \textbf{return} \mathop\bigcup_{\timerof jp \in \expirable(z)}
     \textsc{Infer-Traces}(z\toevent{\timerof jp},\uttrace\tuple{\toevent{\timerof jp},o_{m+1},\emptyset},\phi')
     \]
  where  $\phi_j^p$ is obtained from $\constrof{\uttrace}$
  by replacing $\delay{j}{(m+1)} \leq p$ by $\delay{j}{(m+1)} = p$.
\end{enumerate}
Intuitively, the function
$\textsc{Infer-Traces}(z,\uttrace,\constrof{\uttrace})$ finds
all timers in $\expirable(z)$ by testing for each $k$ whether 
it is possible
to set a timer at the $k$th transition that may expire after the
$m$th transition. Any such timer expiration adds a constraint to
$\constrof{\uttrace}$, which is included in the constraints used to find
further timers.
This is done by finding a timed word is found which maximises the
time within which it is able to expire, subject to the constraints under
which other, already detected, timers cannot expire. If no expiration is
observed, then it is ascertained that no such timer exists.
If such a timer may exist, then some expiration must be observed, either
by a timer set at the $k$th transition and expiring at the $m+1$st transition,
or by a so-far undetected timer that can expire because the membership
query exposes a new timing pattern. In either case, the new detected timer
is added to the word, and the procedure restarts.

\paragraph{Generating MMTs}
Having solved the problem of inferring untimed traces, we can now
define our generalization of $L^*$, which is based on the
Nerode equivalence defined earlier
%% We can now present our algorithm for active learning of MMTs.
%% The main structure of the algorithm is inherited from other active
%% algorithms: it builds on a Nerode equivalence, which is defined based on
%% the set of (untimed) traces of an MMT.
%% Thus, the algorithm has two nontrivial parts.
%% \begin{itemize}
%%   \item
%%     One part is to infer untimed traces of am MMT, essentially building
%%     a prefix tree of untimed traces. This is done by supplying membership
%%     queries, following the ideas of the previous section.
%% \item
%%   One part is to ``fold'' the prefix tree developed in the first part
%%   into a MMnt. This can be done by adapting the suitable tools for active
%%   automata learning, as found in $L^*$
%%   (adapted for Mealy machines in~\cite{Nie03} and to automata with
%%   data registers in~\cite{CasselHJS16}).
%% \end{itemize}
%% We assume that we can observe
%% exact timing of events and that we can observe whenever a timeout eMMvent
%% happens. On the other hand, we cannot observe the setting and resetting of
%% timers, and we cannot observe which timer caused an observed timeout event.


\begin{definition}[Observation Table]
  An \emph{observation table} is a tuple
  $\tuple{U,U^+,V,\smap}$, where
  \begin{itemize}
  \item $U$ is a set of (feasible) {\em input prefixes},
  \item $U^+$ is a set of {\em extended input prefixes}, each of form $ui$ for
    $i \in \extinputs$ (note that $U^+$ is in general not disjoint from $U$),
  \item
    $V$ is a set of input suffixes,
  \item
    $\smap$ maps each extended input prefix $u$ in $U^+$ and input suffix $v$
    to a set of pairs $\tuple{\uttrace,\strace}$ such that 
    $\uttrace\conc\strace$ is an untimed trace with
$\pinpof{\uttrace} = u$ and $\sinpof{\strace} = v$.
   We use $\smappre(u,v)$ for $\uttrace$ and 
   $\smapsuf(u,v)$ for $\strace$.
  \end{itemize}
\end{definition}
For an observation table and $u \in U^+$,
let $\obspre(u)$ denote
\(
\displaystyle\mathop\sqcup_{v \in V}\smappre(u,v)
\),
i.e., $\obspre(u)$ includes manipulation of all timers that may be
exposed by any of the suffixes in $V$.
The observation table defines the following equivalence
Let $u \equiv_{\smap}^{\timerequiv} u'$ denote that
$\timerequiv: \domof{\obspre(u)} \rightarrow \domof{\obspre(u')}$
is a bijection such that there is a bijection $\timerbij$ on $X$ with
$\timerequiv \extendedby\timerbij$ such that for each $v \in V$
\[
\strace \in \smapsuf(u,v)
\qquad \mbox{if and only if} \qquad
\timerequiv(\strace) \in \smapsuf(u',v)
\]
Let $u \equiv_{\smap} u'$ denote that 
$u \equiv_{\smap}^{\timerequiv} u'$ for some bijection
$\timerequiv: \domof{\obspre(u)} \rightarrow \domof{\obspre(u')}$.

Say that an observation table is {\em closed} if for each
$ui \in U^+$ there is a short prefix $u' \in U$ and a $\timerbij$ such that
$ui \equiv_{\smap}^{\timerequiv} u'$.

A closed observation table $\tuple{U,U^+,V,\smap}$ can be used to construct
a hypothesis  MMT $\M = (I, O, Q, q_0, \vars, \delta, \lambda, \remap)$, where
\begin{itemize}
\item
  $Q = U$ and $q_0 = \emptyword$,
\item
  $\vars$ maps each state $u \in Q$ to $\domof{\obspre(u)}$,
\item
  $\delta(u,i)$ is the unique short prefix $u'$ such that
  $ui \equiv_{\smap}^{\timerequiv} u'$. If so, then
  $\remap(u,i) = \remap\circ\timerequiv^{-1}$,
  where $\remap$ is the remapping of the last transition in
  $\obspre(ui)$.
  \item
$\lambda$ is obtained easily from the work (To be done)
\end{itemize}









