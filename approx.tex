\section{Another Try on the Precise Nerode Equivalence}


For a set $V$ of generic untimed input words, let $\instancesof{V}$ be the
set of instances of words in $V$. For a canonical untimed
behavior $\beta$, let $\suffixbehs{S}{\beta}$ be the set of untimed behaviors
$\gamma$ such that
$\beta\cdot\gamma$ is a canonical untimed behavior in $S$. Let
$\getmemorable{S}{\beta}$ be the set of timers $x_i$ in
$x_1 , \ldots x_{|\beta|}$ whose corresponding timeout event
(of form $\toevent{x_i}$) occurs (as an input) in some untimed behavior in
$\suffixbehs{S}{\beta}$.
Let $\getassignment{S}{\beta}$ map each timer $x_i$ in
$\getmemorable{S}{\beta}$ to the unique positive integer to which it
is assigned in the $i$th transition of that behavior.


Let $\suffbij{\beta}{\beta'}$ be the partial injective mapping
on timers that maps each
timer $x_i$ with $i > |\beta|$ to $x_{i + |\beta'| - |\beta|}$.
Intuitively, $\suffbij{\beta}{\beta'}$ maps a timer that is assigned 
in a transition of $\gamma$, where $\gamma$ is a suffix of the canonical
untimed behavior $\beta \cdot \gamma$, to the corresponding timer of
the canonical untimed behavior $\beta'\cdot\gamma$.
For two partial mappings $f$, $g$ on $X$, we let $f \sqcup g$ be their
union. \todobj{Does this need to be further clarified?}

We can now defined the Nerode equivalence, which is parameterized
on a set of generic untimed input words.

\begin{definition}
  \label{def:bj-nerode}
Let $S$ be a timer language \todobj{Define this},
let $\beta$ and $\beta'$ be canonical untimed behaviors in $S$,
and let $f : \getmemorable{S}{\beta}{V} \to \getmemorable{S}{\beta'}{V}$
be a bijection
from $\getmemorable{S}{\beta}$ to $\getmemorable{S}{\beta'}$.
Then $\beta$ and $\beta'$ are \emph{equivalent} under $f$, written
$\beta \equiv_{S}^f \beta'$ iff
\[
\gamma \in \suffixbehs{S}{\beta}
\qquad \mbox{iff} \qquad
(f \sqcup \suffbij{\beta}{\beta'}) (\gamma) \in \suffixbehs{S}{\beta'}
\]
\end{definition}
Intuitively, $\beta \equiv_{S}^f \beta'$ means that $\beta$ and $\beta'$
allow the same suffixes, after renaming
timers assigned in $\beta$ by $f$, and timers assigned in the suffix by
$\suffbij{\beta}{\beta'}$.
We write $\beta \equiv_{S} \beta'$ to denote that
$\beta \equiv_{S}^f \beta'$ for some
$f : \getmemorable{S}{\beta} \to \getmemorable{S}{\beta'}$.

\begin{theorem}
  \label{thm:bj-nerode}
Let $S$ be a timer language.
Then there exists an MMT with feasible canonical untimed behaviors $S$ iff 
$\equiv_S$ has finitely many equivalence classes (finite index).
\end{theorem}
\begin{proof} 
\todobj{This is just a sketch. More care is needed with timers}
``$\Rightarrow$'' Let $\M$ be an MMT, let $S$ be its set of feasible untimed
  behaviors. It follows from \todobj{fix} that $S$ is a timer language.
Suppose that $\beta, \beta' \in S$.
Then there exist (unique) $\delta, \delta$ of $T$ with
$\can{\delta}=\beta$ and $\can{\delta'}=\beta'$.
Suppose $\delta$ and $\delta'$ lead to the same state $q$ of $\M$.
We claim that $\beta \equiv_S \beta'$.
Since $\beta = \can{\delta}$, there exist isomorphisms
$g = g_0 ,\ldots, g_k$  $\beta$ to $\delta$.
Similarly, there exists isomorphisms $g' = g'_0 ,\ldots, g'_l$ from
$\beta'$ to $\delta'$.
Let $f = (g'_l)^{-1} \circ g_k$.
Suppose that, for some untimed behavior $\gamma$, $\beta \cdot \gamma \in S$.
Then there exists an untimed behavior $\zeta$ such that $\delta \cdot \zeta \in T$ and $\can{\delta \cdot \zeta} = \beta \cdot \gamma$.
Moreover, there exists an isomorphism $h = g_k ,\ldots, g_m$ from $\gamma$ to $\zeta$.
Since $\delta \cdot \zeta$ is a feasible behavior in $T$, it follows that
$\delta' \cdot \zeta$ is a feasible behavior in $T$
\todobj{This should follow from the observation that the same paths are possible
  after $\delta$ and $\delta'$ (we have the assumption that all paths are
  feasible}
Thus there exists an untimed behavior $\gamma'$ such that $\can{\delta' \cdot \zeta} = \beta' \cdot \gamma' \in S$.
Moreover, we may construct an isomorphism $h' = g'_l ,\ldots, g'_n$ from $\gamma'$ to $\zeta$.
Then $f = (g'_l)^{-1} \circ g_k \cdots (g'_n)^{-1} \circ g_m$ is an isomorphism from $\gamma$ to $\gamma'$ that extends $f_0$.
We then have $\beta' \cdot f(\gamma) \in S$, as required.
\todobj{To be continued}
\end{proof}

\section{Approximating the Nerode Equivalence}
\label{sec:approx}

In this section, we present an approximation the Nerode equivalence on
untimed behaviors
defined in Definition~\ref{def:nerode}, which is parameterize on a
finite sets of suffixes. This
approximated equivalence can be inferred using a finite set of membership
queries, and therefore be used as a basis for a learning algorithm,
analogously to the use of an approximated Nerode equivalence in
$L^*$~\cite{Ang87}.
A natural approach
would be to define an approximated Nerode equivalence on untimed behaviors,
parameterized by a finite set $V$ of suffixes, by letting 
untimed behaviors $\beta$ and $\beta'$ be equivalent
iff there exists a bijection 
$f_0 : X \to X'$ between the timers that are still active after
$\beta$ and $\beta'$, respectively,
such that for any untimed behavior $\gamma \in V$:
if $\beta \cdot \gamma \in S$ then there exists an isomorphism $f$ that extends $f_0$ such that $\beta' \cdot f(\gamma) \in S$, and vice versa.
%% (b) if $\beta' \cdot \gamma \in S$ then there exists an isomorphism $f$ that extends $f_0^{-1}$ such that $\beta \cdot f(\gamma) \in S$.

In order to make this idea work, we must let the sets $V$ of suffixes be
closed under renaming of timers. 
To illustrate why, consider a simple MMT, which can perform the untimed runs
\(
q_0 \xrightarrow{i_1/o_1, x_1:= 5} q_2
\)
or
\(
q_0 \xrightarrow{i_1/o_1} q_0 \xrightarrow{i_2/o_2, x_1:= 5} q_2
\),
and that from $q_2$ it can perform
\(
q_2 \xrightarrow{\toevent{x_1}/o_3} q_3
\).
The canonical untimed behaviors corresponding to the first two
untimed runs are
\(
\emptyset \xrightarrow{i_1/o_1, x_1:= 5} \set{x_1}
\)
and
\(
\emptyset \xrightarrow{i_1/o_1} \emptyset \xrightarrow{i_2/o_2, x_2:= 5} \set{x_2}
\).
In order to let these two behaviors be equivalent we must discover that
timer $x_1$ can expire after the first one, and that
timer $x_2$ can expire after the second one. By thinking slightly more about
this, one finds out that if the set $V$ of suffixes includes
the effect of a timeout $\toevent{x_1}$ for some timer $x_1$, then it must
include the effects of all timeout events of form $\toevent{x_i}$, otherwise we
may fail to overapproximate the Nerode equivalence of Definition~\ref{def:nerode}.

\todobj{We need to decide how to handle sets of timers in ``partial''
  untimed behaviors}

\todobj{Maybe we should point out that two prefixes $\beta$ and $\beta'$
  can be equivalent even if they assign corresponding timers to different
  values. However, timers assigned in corresponding suffixes must
  be assigned the same values.}

Let us introduce the {\em generic timeout event} $\toevent{p}$, where $p$ can
be regarded as a formal parameter,
which can be instantiated to an arbitrary timout event.
Let $(I \cup \set{\toevent{p}})^*$ be the set of
{\em generic untimed input words}.
An {\em instance} of a generic untimed input word is an untimed input
word obtained by replacing each generic timeout event
$\toevent{p}$ by a concrete timeout event.
For a set $V$ of generic untimed input words, let $\instancesof{V}$ be the
set of instances of words in $V$. For a canonical untimed
behavior $\beta$, let $\apprsuffixbehs{S}{\beta}{V}$ be the set of untimed behaviors
$\gamma$ with $\untimedinputword(\gamma) \in \instancesof{V}$ such that
$\beta\cdot\gamma$ is a canonical untimed behavior in $S$. Let
$\apprgetmemorable{S}{\beta}{V}$ be the set of timers $x_i$ in
$x_1 , \ldots x_{|\beta|}$ whose corresponding timeout event
(of form $\toevent{x_i}$) occurs (as an input) in some untimed behavior in
$\apprsuffixbehs{S}{\beta}{V}$.
Let $\apprgetassignment{S}{\beta}{V}$ map each timer $x_i$ in
$\apprgetmemorable{S}{\beta}{V}$ to the unique positive integer to which it
is assigned in the $i$th transition of that behavior.


Let $\suffbij{\beta}{\beta'}$ be the partial injective mapping
on timers that maps each
timer $x_i$ with $i > |\beta|$ to $x_{i + |\beta'| - |\beta|}$.
Intuitively, $\suffbij{\beta}{\beta'}$ maps a timer that is assigned 
in a transition of $\gamma$, where $\gamma$ is a suffix of the canonical
untimed behavior $\beta \cdot \gamma$, to the corresponding timer of
the canonical untimed behavior $\beta'\cdot\gamma$.
For two partial mappings $f$, $g$ on $X$, we let $f \sqcup g$ be their
union. \todobj{Does this need to be further clarified?}

\todobj{An illustrating example would help the reader here}

We can now defined the approximated Nerode equivalence, which is parameterized
on a set of generic untimed input words.

\begin{definition}
  \label{def:approx-nerode}
Let $S$ be a timer language \todobj{Define this},
let $\beta$ and $\beta'$ be canonical untimed behaviors in $S$,
and let  $V$ be a set of
generic untimed input words.
Let $f : \apprgetmemorable{S}{\beta}{V} \to \apprgetmemorable{S}{\beta'}{V}$
be a bijection
from $\apprgetmemorable{S}{\beta}{V}$ to $\apprgetmemorable{S}{\beta'}{V}$.
Then $\beta$ and $\beta'$ are \emph{equivalent wrp $V$} under $f$, written
$\beta \equiv_{S,V}^f \beta'$ iff
\[
\gamma \in \apprsuffixbehs{S}{\beta}{V}
\qquad \mbox{iff} \qquad
(f \sqcup \suffbij{\beta}{\beta'}) (\gamma) \in \apprsuffixbehs{S}{\beta'}{V}
\]
\end{definition}
Intuitively, $\beta \equiv_{S,V}^f \beta'$ means that $\beta$ and $\beta'$
allow the same suffixes with inputs in $\instancesof{V}$, after renaming
timers assigned in $\beta$ by $f$, and timers assigned in the suffix by
$\suffbij{\beta}{\beta'}$.
We write $\beta \equiv_{S,V} \beta'$ to denote that
$\beta \equiv_{S,V}^f \beta'$ for some
$f : \apprgetmemorable{S}{\beta}{V} \to \apprgetmemorable{S}{\beta'}{V}$.


\todobj{What theorems should we prove about this approximating equivalence?
  We should make the definition of Nerode use the same notation, whenever
  reasonable, to make this easier}

\section{Algorithm for Learning of MMTs}
\label{sec:learning}

In this section, we present an algorithm for learning MMTs in thenuntimed
MAT of~\ref{sec:untimed-mat}, using the approximated Nerode equivalence
presented in Section~\ref{sec:approx}.
The learning algorithm follows the standard pattern for active automata learning
algorithms, such as $L^*$~\cite{Ang87}. It maintains
a set $U$ of {\em short prefixes}, and
  an overapproximation of the Nerode equivalence,
  parameterized represented by a set $V$ of generic untimed input words.
Each short prefix in $U$ is a feasible canonical untimed
behavior, which represents a state in the MMT to be constructed.
The learning algorithm iterates two phases: hypothesis construction and
hypothesis validation.
During hypothesis construction,
the approximation of the Nerode equivalence triggers the expansion of
$U$ and $V$ until two convergence conditions are satisfied that allow
a hypothesis automaton to be formed.
During hypothesis validation, the hypothesis automaton is submitted in an
equivalence query, and returned counterexamples are used to refine
the Nerode equivalence by expanding $V$.

\todobj{Say somewhere that we assume a fixed (un)timed language $S$.}

Let us introduce the two conditions for convergence of the construction phase.
For a feasible untimed word $\beta$, let $\feasibleinputs{\beta}{S}$ be the
set of $i \in \extinputs$ such that there is a feasible
untimed word of form $(\beta \xrightarrow{i/o,\rho} \emptyset)$ in $S$.
For $i \in \feasibleinputs{\beta}{S}$, let $\lambda(\beta,i)$ be the unique
output $o$ such that $\extend{\beta}{i}{o} \in S$. 
%% if $i \in \feasibleinputs{\beta}{S}$; otherwise $\lambda(\beta,i)$ is undefined. 
A set $V$ of generic untimed input words is {\em adequate} if it includes
$I \cup \set{\toevent{p}}$.
Let $U$ be prefix-closed set of feasible untimed behaviors,
and let $V$ be an adequate set of generic untimed input words.
\begin{itemize}
\item
$U$ is {\em closed} wrt.\ $V$ if 
  for each $\beta \in U$ and
  $i \in \feasibleinputs{\beta}{S}$
%%   , which is either in $I$ or of form $\toevent{x_i}$ where $x_i$ is expirable after $\beta$ if
  there is a $\beta' \in U$ such that
  $\extend{\beta}{i}{\lambda(\beta,i)} \equiv_{S,V} \beta'$.
\item
$U$ is {\em timer-consistent} wrt.\ $V$ if 
  for each $\beta \in U$ and
  $i \in \feasibleinputs{\beta}{S}$
  %% $i$, which is either in $I$ or
  %% of form $\toevent{x_i}$ for $x_i$ expirable after $\beta$,
  we have
  $\apprgetmemorable{S}{\extend{\beta}{i}{\lambda(\beta,i)}}{V} \subseteq
  (\apprgetmemorable{S}{\beta}{V} \cup \set{x_{(|\beta|+1)}})$.
\end{itemize}
Closedness ensures that each transition in the MMT to be constructed has a target location. 
Timer-consistency states that each timer which is needed after such
a transition (i.e., a timer set during $\extend{\beta}{i}{\lambda(\beta,i)}$)
is either a timer active after $\beta$ or is started by the last transition, thus
getting the name $x_{(|\beta|+1)}$.
Closedness and timer-consistency allow the construction of a hypothesis MMT.

\begin{definition}[Hypothesis automaton]
  Let $U$ be a non-empty prefix-closed set of untimed behaviors,
  and $V$ a set of generic suffix inputs such that
$U$ is closed and timer consistent wrt.\ $V$. Then the
{\em hypothesis automaton} $\hypoof UV$ is the MMT
$\hypoof UV = (I, O, Q, q_0, \vars, \delta, \lambda, \remap)$, where
\begin{itemize}
\item $Q = U$ and $q_0 = \emptyword$,
\item $\vars$ maps each location $\beta\in U$ to $\apprgetmemorable{S}{\beta}{V}$,
\item $\lambda$ maps each $\beta \in U$ and $i \in \feasibleinputs{\beta}{S}$ to
  the unique $o$ such that $\extend{\beta}{i}{o} \in S$. 
  %% $i$, either in $I$ or of form $\toevent{x_i}$, to the output observed in
  %% reponse to $i$ after $\beta$.
\item $\delta$ maps each $\beta \in U$ and
  $i \in \feasibleinputs{\beta}{S}$ to
  to the unique $\beta' \in U$ such that there is an $f$ with
  $\extend{\beta}{i}{\lambda(\beta,i)} \equiv_{S,V}^f \beta'$.
\item $\remap$
 maps each $\beta \in U$ and $i \in \feasibleinputs{\beta}{S}$ to
  the function
  $\remap(\beta,i):\apprgetmemorable{S}{\beta'}{V} \mapsto (\apprgetmemorable{S}{\beta}{V} \cup \natplus)$ defined as $\rho \circ f^{-1}$, where $\rho$ maps  d
  timer $x_{(|\beta|+1)}$ to
 $\apprgetassignment{S}{\extend{\beta}{i}{\lambda(\beta,i)}}{V}(x_{(|\beta|+1)})$.
\end{itemize}
\end{definition}


Our learning algorithm iterates two phases: hypothesis construction and
hypothesis validation.
During hypothesis construction, 
the approximation of the Nerode equivalence triggers the expansion of
$U$ until it is closed, so that a hypothesis MMT can be formed.
During hypothesis validation, returned counterexamples are used to refine
the Nerode equivalence by expanding $V$.

During {\bf hypothesis construction}, membership queries are performed:
\begin{itemize}
\item for all untimed input words of form $\untimedinputword(\beta) \cdot i$
   for $\beta \in U$ and $i \in \extinputs$: this allows to determine
   $\feasibleinputs{\beta}{S}$ and $\lambda(\beta,i)$ for
   for $\beta \in U$ and $i \in \feasibleinputs{\beta}{S}$.
\item
  for all untimed input words of form $\untimedinputword(\beta) \cdot v$ and
  $\untimedinputword(\beta) \cdot i \cdot v$, where
  $\beta \in U$, $v \in \instancesof{V}$, and
  $i \in \feasibleinputs{\beta}{S}$.
    This allows to compute the approximated Nerode equivalence $\equiv_{S,V}$ on
    the set of untimed words of form $\beta$ and
    $\extend{\beta}{i}{\lambda(\beta,i)}$ with
    $\beta \in U$ and $i \in \feasibleinputs{\beta}{S}$.
    Whenever the set $U$ is not closed wrt.\ $V$, then it is extended:
if there is some $\beta \in U$ and $i$ in $\feasibleinputs{\beta}{S}$
for which there is no $o$ and $\beta' \in U$ such that
$\extend{\beta}{i}{\lambda(\beta,i)} \equiv_{S,V} \beta'$, 
then $\extend{\beta}{i}{\lambda(\beta,i)}$ is added to $U$,
triggering new membership queries.
Whenever the set $U$ is not timer-consistent wrt.\ $V$, then $V$ is extended:
for timer $x_j$ in
$\apprgetmemorable{S}{\extend{\beta}{i}{\lambda(\beta,i)}}{V} \setminus (\apprgetmemorable{S}{\beta}{V} \cup \set{x_{(|\beta|+1)}})$, find an 
untimed behavior of form $\extend{\gamma}{\toevent{x_i}}{o'}$ in
$\apprsuffixbehs{S}{\extend{\beta}{i}{\lambda(\beta,i)}}{V}$.
Then add $i\cdot\untimedinputword(\gamma)\cdot\toevent{p}$ to $V$.
\end{itemize}

When $U$ is closed and timer-consistent wrt.\ $V$, then
    a hypothesis MMT $\hypoof UV$ is constructed and
    validated by submitting it in an equivalence query.
    If the query returns ``yes'', then
    the learning is completed, and $\hypoof UV$ accepts $S$.
    If the query returns a counterexample word $\alpha$, this is used to extend
    $V$ as follows.
    \todobj{The rest of this must still be written}
    %% By the fact that $w$ is a counterexample, there is a suffix
    %% $av$ of $w$ such that $ua \apprnerodeof{\Lang}{V} u'$ but 
    %% $uav \in \Lang \notiff  u'v \in \Lang$ for some $u,u' \in U$.
    %% (To se this, let $w = a_1 \cdots a_n$, and
    %% define the sequence $u_0, u_1, \ldots ,u_{n}$ of short prefixes
    %% in $U$ by $u_0 = \emptyword$ and $u_{i-1}a_i \apprnerodeof{\Lang}{V} u_{i}$ for
    %% $i = 1, \ldots n$, i.e., $u_0 \ldots u_n$ is the sequence of states
    %% visited when $\hypoof UV$ processes $w$.
    %% Let $v_i$ be the suffix $a_{i+1} \cdots a_n$ of $w$ length $n-i$. 
    %% By the fact that $w$ is a counterexample, we have
    %% $u_0v_0 \in \Lang \notiff  u_{n} \in \Lang$, which implies that
    %% $u_{i-1}v_{i-1} \in \Lang \notiff  u_iv_i \in \Lang$ for some $i$;
    %% we can then take $u_{i-1}$ as $u$ and $u_i$ as $u'$.)
    %% This means that $v$ is a new separating suffix that should be added to
    %% $V$. After adding $v$ to $V$, $U$ is no longer closed
    %% wrt.\ $V$, so the algorithm can resume a next round of
    %% hypothesis construction, which will eventually generate a new hypothesis,
    %% etc.


\section{Realizing untimed queries by timed queries}
\todobj{This ection has been untouched for a while. Ignore it for now.}

In order to use the above approximated equivalence for learning, we need to
present a procedure for constructing the set
$\apprsuffixbehs{S}{\beta}{V}$ by a sequence of timed membership queries.

We should also construct an automaton from a set of results of such
suffix queries, provided they satisfy some conditions
\todobj{closedness, etc, which we must define}

Let us first present a procedure for answering suffix queries. It is
sufficient to perform them for one generic suffix at a time.
The input to a suffix query is a (feasible) untimed behavior $\beta$ an a
generic untimed input behavior $v$. It returns
$\apprsuffixbehs{S}{\beta}{\set{v}}$. To compute this, it must be determined
\begin{itemize}
\item which instantiations of generic timeouts in $v$ are feasible after $\beta$, and
\item what is the output in response to an input.
\end{itemize}
The second item is trivially answered by observing the output in response to
each relevant input. Note that if a behavior $\beta$ is feasible, then
any extension of $\beta$ by a non-timeout input is trivially feasible, simply
by supplying the input as fast as possible. Thus the only non-trivial part
of answering a suffix query is to determine which instantiations of a generic
timeout in $v$ are feasible. This is easily reduced to the problem of
determining, for a feasible behavior $\beta$, which timeouts of form
$\toevent{x_i}$ with $i \leq |\beta|$ are feasible (note that $\beta$ here in
general denotes an extension of the $\beta$ supplied as prefix in a
suffix query). Let us now describe how this can be done.

In order to determine which behaviors of form $\beta \cdot \toevent{x_i}$
are feasible, we perform a timed membership query, which provide the longest
possible time delay between the $i$th transition in $\beta$ and the time
of any other timeout that can feasibly expire after $\beta$. In order to
maximize this time, we need to know which other timeouts may expire while
performing $\beta \cdot \toevent{x_i}$. Such timeouts are either expiring
as part of $\beta$, or disturb the execution of $\beta \cdot \toevent{x_i}$,
in which case our membership query must know how to prevent them from occuring.

Les us introduce notation. Let $\beta$ be of form
\(
  {i_1/o_1, \rho_1} \ \cdot \ {i_n/o_n, \rho_n}
\)
We are looking for a corresponding timed behavior of form 
\[
\tvals_0 \xrightarrow{d_1} \tvals'_0 \xrightarrow{i_1/o_1, \rho_1}
\quad \cdots \quad
\xrightarrow{d_n} \tvals'_n \xrightarrow{i_n/o_n, \rho_n} \tvals_n
\xrightarrow{d_{n+1}} \tvals'_{n+1} \xrightarrow{\toevent{x_i}/o_{n+1}, \rho_n}
\]
The timed membership queries need to select values
of $\vect{d}{n+1}$, and gradually adds new timers to the word together
with constraints on $\vect{d}{n+1}$ induced by these timers.
Let $\delay{j}{k}$ denote $d_{j+1} + d_{j+2} + \cdots + d_k$.

The algorithm maintains an increasing constraint $\constr$ on delays of form
$\delay jk$. Initially, the constraint contains the conjunct
$\delay jk = D$ whenever $i_k$ is of form $\toevent{x_j}$ and
$\rho_j$ sets $x_j$ to $D$.
Thereafter, the following procedure is performed
  \begin{enumerate}
  \item
    find $\vect d{{n+1}}$ that maximizes $\delay{i}{(n+1)}$ given
    $\constr$ (note that $d_{n+1} = \infty$ is allowed)
  \item
    supply membership query with delay values $\vect d{{n+1}}$.
\begin{itemize}
  \item
    {\bf if} the output is of form $\beta$ followed by $\toevent{x_i}$, then
    report that $\toevent{x_i}$ is feasible and stop
  \item
    {\bf else if} no timeout occurs within $d_{n+1}$ after $\beta$, report
    that $\toevent{x_i}$ is not feasible and stop
  \item
    {\bf else if} another timeout of form $\toevent{x_j}$ occurs before
    the $k$th input, this means that timer $x_j$ is assigned a value
    $D_j$ at the $j$ transition and may expire before the $k$th transition
    in the untimed trace. In order to prevent this from happening,
    add the constraint $\delay jk < D_j$ to $\constr$ and start again
    from step 1.
\end{itemize}
  \end{enumerate}
  Intuitively, the procedure aims to find a timed membership query which maximise
  the time within which $\toevent{x_i}$ is able to expire,
  subject to the constraints under which timers that expire in $\beta$ expire
  as scheduled, and under which any other timers do not expire. These
  other timers may not be known when the procedure starts, and so their
  corresponding constraints are added when they are detected: this happens
  when they expire unexpectectly.

  Note that conjunctions of constraints on delays $\delay{j}{k}$ can be represented as DBM, as is standard for timed automata.




