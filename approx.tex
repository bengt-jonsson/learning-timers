\section{Another Try on ``Zones and constraints''}

In order to implement an untimed teacher using a timed teacher, we need a
basic machinery to determine whether an untimed behavior is feasible, i.e.,
whether it can be derived from a timed word. This can be done using
well-established techniques for manipulating difference-bound matrices
(DBMs) that are in standard use for analyzing timed
automata~\cite{Di89,BengtssonY03}.
In this section, we describe an adaptation of such techniques to
our setting.

Let $\beta$ be an untimed behavior in canonical form:
\begin{eqnarray*}
\beta & = & \emptyset \uttrans{i_1}{o_1}{\rho_1} X_1  \cdots X_{k-1} \uttrans{i_k}{o_k}{\rho_k} X_k.
\end{eqnarray*}
We would like to determine for which values $d_1, \ldots , d_{k+1}$
a corresponding timed behavior
\[
\tvals_0 \dtrans{d_1} \tvals'_0 \uttrans{i_1}{o_1}{\rho_1}
\quad \cdots \quad
\dtrans{d_k} \tvals'_k \uttrans{i_k}{o_k}{\rho_k} \tvals_k
\dtrans{d_{k+1}} \tvals'_{k+1}
%% \uttrans{\toevent{x_i}}{o_{n+1}}{\rho_n}
\]
is possible. We solve this problem by producing a constraint over the
values $d_1, \ldots , d_{k+1}$. In order to use DBM techniques, we first
change representation by letting
$t_j = d_1 + \cdots + d_j$ for $j = 1 , \ldots, k+1$. Intuitively, $t_j$ is
the time of occurrence of the $j$th transition in $\beta$.
We now associate with $\beta$ a conjunction of difference constraints, denoted
$\Constraints{\beta}$, consisting of
\todobj{We assume that delays are always non-zero. Check how this is said in
  the paper}
\begin{itemize}
%% \item
%% $0 < t_1 \leq d_{\max}$,
%% \item
%% for each index $j < k$:  $0 <  t_{j+1} - t_j \leq d_{\max}$,
\item
for each index $j$ with $1 \leq j \leq k$:  $0 <  t_{j+1} - t_j$,
\item
for each timeout event $i_j = \toevent{x_l}$: $t_j - t_l = \rho_l(x_l)$,
\item
for each clock $x_l$ that is started but does not timeout: $t_j -t_l < \rho_l(x_l)$,
where $j$ is the largest index such that $x_l \in X_j$,
%% \item
%% for each pair of distinct indices $j$ and $l$ with $i_j, i_l \in I$: $\Frac{t_j} \neq \Frac{t_l}$ 
%% (to express that the fractional parts of $t_j$ and $t_l$ are different).
\end{itemize}
Using standard DBM techniques, we can check whether $\Constraints{\beta}$ is satisfiable by saturating it (i.e., closing it under implied constraints, which
will always be of form
$n < t_j - t_l < m$ and $t_j - t_l = m$ for integers $n,m$), and checking that
all such differences allow $t_{j+1} - t_j$ be positive for each $j$.
We infer that $\beta$ is feasible iff the set of constraints $\Constraints{\beta}$ is satisfiable.
Moreover, if $\beta$ is feasible, it is easy to see that there is a solution
such that $\Frac{t_j} \neq \Frac{t_l}$ for each pair of distinct indices $j$ and $l$ with $i_j, i_l \in I$.

From the saturated version of $\Constraints{\beta}$, we also derive a constraint,
denoted $\Zone{\beta}$,
which characterizes the possible timer valuations $\tvals_k$ in a timed
behavior of the above form.  The constraint $\Zone{\beta}$
contains for each pair of timers $x_i,x_j$ in $X_k$ the conjunct
\[
(m + \rho_j(x_j) - \rho_i(x_i)) < \tvals_k(x_j) -\tvals_k(x_i) < (n + \rho_j(x_j) - \rho_i(x_i))
\]
whenever the saturated version of $\Constraints{\beta}$ contains the conjunct
\(
m < t_j - t_i < n
\).
(This can be derived using
$\tvals_k(x_j) = \rho_j(x_j) - (t_k - t_j)$
and
$\tvals_k(x_i) = \rho_i(x_i) - (t_k - t_i)$).

We can derive the following lemmas.

\begin{lemma}
\label{lemma: feasibility concatenation}
Suppose $\beta, \beta'$ are untimed behaviors such that
$\Zone{\beta} = \Zone{\beta'}$. Let $\gamma$ be any untimed behavior.
Then $\beta \cdot \gamma$ is feasible iff $\beta' \cdot \gamma$ is feasible.
\end{lemma}

\begin{lemma}
\label{lemma finitely many zones}
$\{ \Zone{\beta} \mid \beta \mbox{ feasible untimed behavior of } \M \}$ is finite.
\end{lemma}
\begin{proof}
  This follows by noting that each MMT has a fixed set of clocks, and that
  the constraints in $\Zone(\beta)$ \todobj{This needs some thought and,
    to truncate zones}
\end{proof}

Let $\beta$ be a feasible untimed behavior and let $x \in X$ be a timer. Then we say that $x$ is \emph{expirable} after $\beta$
if there exists a valuation in $\Zone{\beta}$ in which $x$ is minimal.

\begin{lemma}
\label{expirable}
Suppose $\beta$ is a feasible untimed behavior with $\Last{\beta} = Y$ and $Y \uttrans{\toevent{x}}{o}{\rho} Y'$ is an untimed behavior.
Then $x$ is expirable after $\beta$ iff $\beta \uttrans{\toevent{x}}{o}{\rho} Y'$ is feasible.
\end{lemma}


\todofv{Move next lemma to earlier section}

\begin{lemma}
\label{not timed}
Suppose $\M, \N$ are MMTs with $\M \not\approx_{\mathit{timed}} \N$.
Then there exists a transparent timed word $w$ of $\M$ that is not a timed word of $\N$.
\end{lemma}



\section{Approximating the Nerode Equivalence}
\label{sec:approx}

In this section, we present an approximation the Nerode equivalence on
untimed behaviors
defined in Definition~\ref{def:nerode}, which is parameterized on a
finite sets of suffixes. This
approximated equivalence can be inferred using a finite set of membership
queries, and therefore be used as a basis for a learning algorithm,
analogously to the use of an approximated Nerode equivalence in
$L^*$~\cite{Ang87}.
A natural approach
would be to define an approximated Nerode equivalence on untimed behaviors,
parameterized by a finite set $V$ of untimed input words (hereafter often
called {\em suffixes}), by letting
untimed behaviors $\beta$ and $\beta'$ be equivalent
iff there exists a bijection 
$f_0 : X \to X'$ between the timers that are still active after
$\beta$ and $\beta'$, respectively,
such that for any untimed behavior $\gamma$ with $\untimedinputword(\gamma)
\in V$:
if $\beta \cdot \gamma \in S$ then there exists an isomorphism $f$ that extends $f_0$ such that $\beta' \cdot f(\gamma) \in S$, and vice versa.
%% (b) if $\beta' \cdot \gamma \in S$ then there exists an isomorphism $f$ that extends $f_0^{-1}$ such that $\beta \cdot f(\gamma) \in S$.

In order to make this idea work, we must let the sets $V$ of suffixes be
closed under renaming of timers that are active after a prefix $\beta$.
To illustrate why, consider a simple MMT, which can perform the untimed runs
\(
q_0 \uttrans{i_1}{o_1}{x_1:= 5} q_2
\)
or
\(
q_0 \uttrans{i_1}{o_1}{} q_0 \uttrans{i_2}{o_2}{x_1:= 5} q_2
\),
and that from $q_2$ it can perform
\(
q_2 \uttrans{\toevent{x_1}}{o_3}{} q_3
\).
The canonical untimed behaviors corresponding to the first two
untimed runs are
\(
\emptyset \uttrans{i_1}{o_1}{x_1:= 5} \set{x_1}
\)
and
\(
\emptyset \uttrans{i_1}{o_1}{} \emptyset \uttrans{i_2}{o_2}{x_2:= 5} \set{x_2}
\).
In order to let these two behaviors be equivalent we must discover that
timer $x_1$ can expire after the first one, and that
timer $x_2$ can expire after the second one. By thinking slightly more about
this, one finds out that if the set $V$ of suffixes includes
the effect of a timeout $\toevent{x_1}$ for some timer $x_1$, then it must
include the effects of the timeout events of form $\toevent{x_i}$ for any
timer $x_i$ that is assigned in a prefix, otherwise we
may fail to overapproximate the Nerode equivalence of Definition~\ref{def:nerode}.

Let us introduce notation to make the subsequent development more convenient. 
Recall that a canonical untimed behavior is \emph{canonical} when, for each $j$,
the timer that is updated in the $j$-th event (if any) is equal to $x_j$.
It is {\em lean} if it is canonical and
includes only timers that expire during the behavior. 
Since timers in lean behaviors are uniquely determined by the labels on
transition, we can denote lean behaviors simply as sequences
$i_1/o_1,\rho_1 \cdots i_n/o_n,\rho_n$ of input/output/assignment triples.
For behaviors that are to be appended as suffixes, we need to distinguish
timers that are assigned in the suffix from timers that are assigned in a prefix.
Therefore, extend the set of timers by the set $Y = \set{y_1,y_2,\ldots}$ of
{\em suffix timers}, which is disjoint from $X$.
Define a {\em suffix behavior} to be a sequence
$i_1/o_1,\rho_1 \cdots i_m/o_m,\rho_m$ of input/output/assignment triples,
in which the inputs are in $I$, of form $\toevent{x_j}$ for $x_j \in X$, or
of form $\toevent{y_j}$ for $y_j \in Y$, but where assignments may assign only
to timers in $Y$. Such a suffix behavior is {\em lean} if
timer $y_j$ is assigned only by $\rho_j$, each timeout event occurs at most once, and all assigned timers in $Y$ expire sometime after their assignment.

For integer $k \geq 0$, let $\suffmap{k}$ be the injective mapping on
$Y$ which maps each $y_j$ to $y_{j+k}$.  We apply mappings $\suffmap{k}$ to
lean suffix behaviors in the natural way.

Let $\beta$ be a lean behavior. We say that 
a lean suffix behavior $\gamma$ is a {\em $\beta$-suffix} if
there is a canonical behavior $\beta'$ with $\beta \sqsubseteq \beta'$ such that
$\beta'\cdot\suffmap{|\beta|}(\gamma)$ is a lean behavior. In this case we
use $\beta;\gamma$ to denote $\beta'\cdot\suffmap{|\beta|}(\gamma)$.

We can define general residual languages, by letting
$\suffixbehs{S}{\beta}$ be the set $\beta$-suffixes.
Let $\getmemorable{S}{\beta}$ be the set of timers $x_i$ in
$x_1 , \ldots x_{|\beta|}$ whose corresponding timeout event
(of form $\toevent{x_i}$) occurs (as an input) in some $\beta$-suffix.
Let $\getassignment{S}{\beta}$ map each timer $x_i$ in
$\getmemorable{S}{\beta}$ to the unique positive integer to which it
is assigned in the $i$th transition of $\beta$.

Let an {\em input suffix} be a sequence of elements
in $I$, of form $\toevent{x_j}$ for $x_j \in X$, or
of form $\toevent{y_j}$ for $y_j \in Y$.
A set $V$ of input suffixes is {\em adequate} if it is closed under permutations
on $X$ and includes all input suffixes of length one.

For an adequate set $V$ of input suffixes, and a lean behavior $\beta$,
let $\apprsuffixbehs{S}{\beta}{V}$ be the set of $\beta$-suffixes $\gamma$
with $\untimedinputword(\gamma) \in V$.
Let $\apprgetmemorable{S}{\beta}{V}$ be the set of timers $x_i$ in
$x_1 , \ldots x_{|\beta|}$ whose corresponding timeout event
(of form $\toevent{x_i}$) occurs (as an input) in some untimed behavior in
$\apprsuffixbehs{S}{\beta}{V}$.
Let $\apprgetassignment{S}{\beta}{V}$ map each timer $x_i$ in
$\apprgetmemorable{S}{\beta}{V}$ to the unique positive integer to which it
is assigned in the $i$th transition of that behavior.


%% \todobj{Maybe we should point out that two prefixes $\beta$ and $\beta'$
%%   can be equivalent even if they assign corresponding timers to different
%%   values. However, timers assigned in corresponding suffixes must
%%   be assigned the same values.}

%% Let us introduce the {\em generic timeout event} $\toevent{p}$, where $p$w can
%% be regarded as a formal parameter,
%% which can be instantiated to an arbitrary timout event.
%% Let $(I \cup \set{\toevent{p}})^*$ be the set of
%% {\em generic untimed input words}.
%% An {\em instance} of a generic untimed input word is an untimed input
%% word obtained by replacing each generic timeout event
%% $\toevent{p}$ by a concrete timeout event.
%% For a set $V$ of generic untimed input words, let $\instancesof{V}$ be the
%% set of instances of words in $V$. For a canonical untimed
%% behavior $\beta$, let $\apprsuffixbehs{S}{\beta}{V}$ be the set of untimed behaviors
%% $\gamma$ with $\untimedinputword(\gamma) \in \instancesof{V}$ such that
%% $\beta\cdot\gamma$ is a canonical untimed behavior in $S$. Let
%% $\apprgetmemorable{S}{\beta}{V}$ be the set of timers $x_i$ in
%% $x_1 , \ldots x_{|\beta|}$ whose corresponding timeout event
%% (of form $\toevent{x_i}$) occurs (as an input) in some untimed behavior in
%% $\apprsuffixbehs{S}{\beta}{V}$.
%% Let $\apprgetassignment{S}{\beta}{V}$ map each timer $x_i$ in
%% $\apprgetmemorable{S}{\beta}{V}$ to the unique positive integer to which it
%% is assigned in the $i$th transition of that behavior.


%% Let $\suffbij{\beta}{\beta'}$ be the partial injective mapping
%% on timers that maps each
%% timer $x_i$ with $i > |\beta|$ to $x_{i + |\beta'| - |\beta|}$.
%% Intuitively, $\suffbij{\beta}{\beta'}$ maps a timer that is assigned 
%% in a transition of $\gamma$, where $\gamma$ is a suffix of the canonical
%% untimed behavior $\beta \cdot \gamma$, to the corresponding timer of
%% the canonical untimed behavior $\beta'\cdot\gamma$.
%% For two partial mappings $f$, $g$ on $X$, we let $f \sqcup g$ be their
%% union. \todobj{Does this need to be further clarified?}

%% \todobj{An illustrating example would help the reader here}

We can now defined the approximated Nerode equivalence, which is parameterized
on an adequate set of input suffixes.

\begin{definition}
  \label{def:approx-nerode}
Let $S$ be a timer language \todobj{Define this},
let $\beta$ and $\beta'$ be canonical untimed behaviors in $S$,
and let  $V$ be an adequate set of input suffixes.
Let $f : \apprgetmemorable{S}{\beta}{V} \to \apprgetmemorable{S}{\beta'}{V}$
be a bijection
from $\apprgetmemorable{S}{\beta}{V}$ to $\apprgetmemorable{S}{\beta'}{V}$.
Then $\beta$ and $\beta'$ are \emph{equivalent wrp $V$} under $f$, written
$\beta \equiv_{S,V}^f \beta'$ iff
\[
\gamma \in \apprsuffixbehs{S}{\beta}{V}
\qquad \mbox{iff} \qquad
f(\gamma) \in \apprsuffixbehs{S}{\beta'}{V}
\]
\end{definition}
Intuitively, $\beta \equiv_{S,V}^f \beta'$ means that $\beta$ and $\beta'$
allow the same suffixes with inputs in $V$, after renaming
timers assigned in $\beta$ by $f$.
We write $\beta \equiv_{S,V} \beta'$ to denote that
$\beta \equiv_{S,V}^f \beta'$ for some
$f : \apprgetmemorable{S}{\beta}{V} \to \apprgetmemorable{S}{\beta'}{V}$.


\todobj{What theorems should we prove about this approximating equivalence?
  We should make the definition of Nerode use the same notation, whenever
  reasonable, to make this easier}

\section{Algorithm for Learning of MMTs}
\label{sec:learning}

In this section, we present an algorithm for learning MMTs in then untimed
MAT of~\ref{sec:untimed-mat}, using the approximated Nerode equivalence
presented in Section~\ref{sec:approx}.
The learning algorithm follows the standard pattern for active automata learning
algorithms, such as $L^*$~\cite{Ang87}. It maintains
a set $U$ of {\em short prefixes}, and
  an overapproximation of the Nerode equivalence,
  parameterized by a set $V$ of input suffixes.
Each short prefix in $U$ is a feasible canonical untimed
behavior, which represents a state in the MMT to be constructed.
The learning algorithm iterates two phases: hypothesis construction and
hypothesis validation.
During hypothesis construction,
the approximation of the Nerode equivalence triggers the expansion of
$U$ and $V$ until two convergence conditions are satisfied that allow
a hypothesis automaton to be formed.
During hypothesis validation, the hypothesis automaton is submitted in an
equivalence query, and returned counterexamples are used to refine
the Nerode equivalence by expanding $V$.

\todobj{Say somewhere that we assume a fixed (un)timed language $S$.}

Let us introduce the two conditions for convergence of the construction phase.
For a feasible untimed word $\beta$, let $\feasibleinputs{\beta}{S}$ be the
set of $i \in \extinputs$ such that there is a $\beta$-suffix of form
$i/o,\rho$ for some $o$ and $\rho$.
For $i \in \feasibleinputs{\beta}{S}$, let $\lambda(\beta,i)$ be the unique
output $o$ such that $i/o,\rho$ is a $\beta$-suffix for some $\rho$.
%% A set $V$ of generic untimed input words is {\em adequate} if it includes
%% $I \cup \set{\toevent{p}}$.
Let $U$ be a prefix-closed set of feasible lean behaviors.
and let $V$ be an adequate set of input suffixes.
\begin{itemize}
\item
$U$ is {\em closed} wrt.\ $V$ if 
  for each $\beta \in U$ and
  $i \in \feasibleinputs{\beta}{S}$
%%   , which is either in $I$ or of form $\toevent{x_i}$ where $x_i$ is expirable after $\beta$ if
  there is a $\beta' \in U$ such that
  $\beta;i/\lambda(\beta,i) \equiv_{S,V} \beta'$.
\item
$U$ is {\em timer-consistent} wrt.\ $V$ if 
  for each $\beta \in U$ and
  $i \in \feasibleinputs{\beta}{S}$
  %% $i$, which is either in $I$ or
  %% of form $\toevent{x_i}$ for $x_i$ expirable after $\beta$,
  we have
  $\apprgetmemorable{S}{\beta;\lambda(\beta,i)}{V} \subseteq
  (\apprgetmemorable{S}{\beta}{V} \cup \set{x_{(|\beta|+1)}})$.
\end{itemize}
Closedness ensures that each transition in the MMT to be constructed has a target location. 
Timer-consistency states that each timer which is needed after such
a transition (i.e., a timer set during $\beta;7O\lambda(\beta,i)$)
is either a timer active after $\beta$ or is started by the last transition, thus
getting the name $x_{(|\beta|+1)}$.
Closedness and timer-consistency allow the construction of a hypothesis MMT.

\todobj{Note that lean behaviors of form $\beta;i/\lambda(\beta,i),\rho$
  always have an empty $\rho$, hence we can omit $\rho$}

\begin{definition}[Hypothesis automaton]
\label{def:hypo}
  Let $U$ be a non-empty prefix-closed set of untimed behaviors,
  and $V$ an adequate set of input suffixes such that
  $U$ is closed and timer consistent wrt.\ $V$. Then the
{\em hypothesis automaton} $\hypoof UV$ is the MMT
$\hypoof UV = (I, O, Q, q_0, \vars, \delta, \lambda, \remap)$, where
\begin{itemize}
\item $Q = U$ and $q_0 = \emptyword$,
\item $\vars$ maps each location $\beta\in U$ to $\apprgetmemorable{S}{\beta}{V}$,
\item $\lambda$ maps each $\beta \in U$ and $i \in \feasibleinputs{\beta}{S}$ to
  the unique $o$ such that $\extend{\beta}{i}{o} \in S$. 
  %% $i$, either in $I$ or of form $\toevent{x_i}$, to the output observed in
  %% reponse to $i$ after $\beta$.
\item $\delta$ maps each $\beta \in U$ and
  $i \in \feasibleinputs{\beta}{S}$ to
  to the unique $\beta' \in U$ such that there is an $f$ with
  $\extend{\beta}{i}{\lambda(\beta,i)} \equiv_{S,V}^f \beta'$.
\item $\remap$
 maps each $\beta \in U$ and $i \in \feasibleinputs{\beta}{S}$ to
  the function
  $\remap(\beta,i):\apprgetmemorable{S}{\beta'}{V} \mapsto (\apprgetmemorable{S}{\beta}{V} \cup \natplus)$ defined as $\rho \circ f^{-1}$, where $\rho$ maps 
  timer $x_{(|\beta|+1)}$ to
$\apprgetassignment{S}{(\extend{\beta}{i}{\lambda(\beta,i)})}{V}(x_{(|\beta|+1)})$.
\end{itemize}
\end{definition}


Our learning algorithm iterates two phases: hypothesis construction and
hypothesis validation.
During hypothesis construction, 
the approximation of the Nerode equivalence triggers the expansion of
$U$ and $V$ until $U$ is closed and timer-consistent wrpt.\ $V$,
so that a hypothesis MMT can be formed.
During hypothesis validation, returned counterexamples are used to refine
the approximated Nerode equivalence by expanding $V$.

During {\bf hypothesis construction}, membership queries are performed:
\begin{itemize}
\item for all untimed input words of form $\untimedinputword(\beta) \cdot i$
   for $\beta \in U$ and $i \in \extinputs$: this allows to determine
   $\feasibleinputs{\beta}{S}$ and $\lambda(\beta,i)$
   for $\beta \in U$ and $i \in \feasibleinputs{\beta}{S}$.
\item
  for all untimed input words of form $\untimedinputword(\beta) \cdot v$ and
  $\untimedinputword(\beta) \cdot i \cdot v$, where
  $\beta \in U$, $v \in \instancesof{V}$, and
  $i \in \feasibleinputs{\beta}{S}$.
    This allows to compute the approximated Nerode equivalence $\equiv_{S,V}$ on
    the set of untimed words of form $\beta$ and
    $\extend{\beta}{i}{\lambda(\beta,i)}$ with
    $\beta \in U$ and $i \in \feasibleinputs{\beta}{S}$.
    Whenever the set $U$ is not closed wrt.\ $V$, then it is extended:
if there is some $\beta \in U$ and $i$ in $\feasibleinputs{\beta}{S}$
for which there is no $o$ and $\beta' \in U$ such that
$\extend{\beta}{i}{\lambda(\beta,i)} \equiv_{S,V} \beta'$, 
then $\extend{\beta}{i}{\lambda(\beta,i)}$ is added to $U$,
triggering new membership queries.
Whenever the set $U$ is not timer-consistent wrt.\ $V$, then $V$ is extended:
for timer $x_j$ in
$\apprgetmemorable{S}{\extend{\beta}{i}{\lambda(\beta,i)}}{V} \setminus (\apprgetmemorable{S}{\beta}{V} \cup \set{x_{(|\beta|+1)}})$, find an 
untimed behavior of form $\extend{\gamma}{\toevent{x_i}}{o'}$ in
$\apprsuffixbehs{S}{\extend{\beta}{i}{\lambda(\beta,i)}}{V}$.
Then add $i\cdot\untimedinputword(\gamma)\cdot\toevent{p}$ to $V$.
\end{itemize}

When $U$ is closed and timer-consistent wrt.\ $V$, then
a hypothesis MMT $\hypoof UV$ is constructed and
validated by submitting it in an equivalence query.
If the query returns ``yes'', then
the learning is completed, and $\hypoof UV$ accepts $S$.
If the query returns a counterexample word $\alpha$, this is used to extend
$V$ as follows. We assume w.l.o.g.\ that no proper prefix of $\alpha$ is
a counterexample. 
By the fact that $\alpha$ is a counterexample, there is a suffix
$i/o,\rho \cdot \gamma$ of $\alpha$
such that $\beta\cdot i/o,\rho \equiv_{S,V} \beta'$ but
$\beta \cdot i/o,\rho \cdot \gamma \in S \notiff \beta' \cdot \gamma \in S$
for some $\beta,\beta' \in U$.
(To se this, let $\alpha = i_1/o_1,\rho_1 \cdots i_n/o_n,\rho_n$, and
define the sequence $\beta_0, \beta_1, \ldots ,\beta_{n}$ of short prefixes
in $U$ by $\beta_0 = \emptyword$ and
$\beta_{j-1}i_j/o_j,\rho_j \equiv_{S,V} \beta_{i}$ for
$j = 1, \ldots n$, i.e., $\beta_0 \ldots \beta_n$ is the sequence of states
visited when $\hypoof UV$ processes $\alpha$.
Let $\gamma_j$ be the suffix $i_{j+1}/o_{j+1}\rho_{j+1} \cdots i_n/o_n,\rho_n$
of $\alpha$ of length $n-j$. 
By the fact that $\alpha$ is a counterexample, we have
$\beta_0\cdot\gamma_0 \in S \notiff  \beta_{n} \in S$, which implies that
$\beta_{j-1}\cdot\gamma_{j-1} \in S \notiff \beta_j\cdot\gamma_j \in S$
for some $j$;
we can then take $\beta_{j-1}$ as $\beta$ and $\beta_j$ as $\beta'$.)
This means that $\gamma$ is a new separating suffix, and that $V$ should be
extended with the $v$ such that
$\untimedinputword(\gamma) \in \instancesof{\set{v}}$
should be added to
$V$. After adding $v$ to $V$, $U$ is no longer closed
wrt.\ $V$, so the algorithm can resume a next round of
hypothesis construction, which will eventually generate a new hypothesis,
etc.

\todobj{Should we insert a pseudocode description of the algorithm?}

The algorithm enjoys the following properties, which are similar to those
enjoyed by active automata learning algorithms for regular languages,
e.g.,~\cite{Ang87}.

\begin{theorem}
  \label{thm:alg:termination}
Given an MMT $\M$ whose normal form has $n$ states, 
algorithm XXX terminates and produces an equivalence MMT in normal form
using at most $n$ equivalence queries, and
$Y$ untimer membership queries.
\end{theorem}
   
\begin{proof}
Starting from some initial approximations (e.g., the singleton
set consisting of the empty word), the sets $U$ and $V$ are
successively extended, until $U$ contains one element of each equivalence
class of $\equiv_{S}$, and $\equiv_{S,V}$ coincides with
$\equiv_{S}$. 
At termination the hypothesis is correct, by definition of equivalence query.
During the construction, $U$ will never contain two elements that are
equivalent wrp. $\M$.
Since each round of hypothesis construction and validation adds at least one
word to $U$, there can be at most $n$ equivalence queries.
\end{proof}

\todobj{This is to be fixed}
Since each equivalence query adds only one
word to $V$, this means that $|V| \leq n$ when the algorithm finishes,
implying that in total, at most $n^2|I|$ membership queries
will be performed during hypothesis construction.
During hypothesis
validation, at most $2\log(m)$ membership queries need be performed
(in addition to the equivalence query), where
$m$ is the length of the largest counterexample word returned.


